{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230\u6df1\u6d77\u5927\u83e0\u841d\ud83d\udc19 \u00b6 Resources section \u00b6 \u5173\u4e8eOJ\u7684\u4ecb\u7ecd(OJ instroductions) \u5173\u4e8e\u5e73\u65f6\u6709\u7528\u7684\u8d44\u6e90(Learning resources) Codeforces section \u00b6 \u677f\u5237 cf1600 ( \u867d\u7136\u5f00\u59cb\u5237\u4e86\u4f46\u8fd8\u6ca1\u5b8c\u5168\u5f00\u59cb\u5237.jpg ) ICPC/CCPC section \u00b6 \u5237\u9898\u4ee5\u53ca\u6bd4\u8d5b\u540e\u8865\u9898 ICPC \u6606\u660e kunming Virtual Judge section \u00b6 Kuangbin\u7684\u9898 \u4e13\u9898\u4e00 \u7b80\u5355\u641c\u7d22 Leetcode section \u00b6 \u6bd4\u8d5b\u548c\u5e73\u65f6\u7684\u9898 Miscellaneous section \u00b6 \u6742\u9879 About section \u00b6 \u5173\u4e8e","title":"\u4ecb\u7ecd"},{"location":"#_1","text":"","title":"\u6b22\u8fce\u6765\u5230\u6df1\u6d77\u5927\u83e0\u841d\ud83d\udc19"},{"location":"#resources-section","text":"\u5173\u4e8eOJ\u7684\u4ecb\u7ecd(OJ instroductions) \u5173\u4e8e\u5e73\u65f6\u6709\u7528\u7684\u8d44\u6e90(Learning resources)","title":"Resources section"},{"location":"#codeforces-section","text":"\u677f\u5237 cf1600 ( \u867d\u7136\u5f00\u59cb\u5237\u4e86\u4f46\u8fd8\u6ca1\u5b8c\u5168\u5f00\u59cb\u5237.jpg )","title":"Codeforces section"},{"location":"#icpcccpc-section","text":"\u5237\u9898\u4ee5\u53ca\u6bd4\u8d5b\u540e\u8865\u9898 ICPC \u6606\u660e kunming","title":"ICPC/CCPC section"},{"location":"#virtual-judge-section","text":"Kuangbin\u7684\u9898 \u4e13\u9898\u4e00 \u7b80\u5355\u641c\u7d22","title":"Virtual Judge section"},{"location":"#leetcode-section","text":"\u6bd4\u8d5b\u548c\u5e73\u65f6\u7684\u9898","title":"Leetcode section"},{"location":"#miscellaneous-section","text":"\u6742\u9879","title":"Miscellaneous section"},{"location":"#about-section","text":"\u5173\u4e8e","title":"About section"},{"location":"about/","text":"\u5173\u4e8e \u00b6 \u53ea\u662f\u60f3\u5230\u9700\u8981\u4e00\u4e2a\u7f51\u7ad9\u5b58\u50a8\u4e00\u4e9b\u601d\u8003, \u6240\u4ee5\u5c31\u8fd9\u4e48\u505a\u4e86 \u5176\u4ed6 \u00b6 \u5982\u679c\u89c9\u5f97\u5199\u7684\u4e0d\u597d, \u8bf7\u76f4\u63a5pull request\ud83d\udc7b \u5982\u679c\u89c9\u5f97\u6709\u5e2e\u52a9, \u90a3\u5f53\u7136\u662f\u975e\u5e38\u597d\u7684\u5566~","title":"intro"},{"location":"about/#_1","text":"\u53ea\u662f\u60f3\u5230\u9700\u8981\u4e00\u4e2a\u7f51\u7ad9\u5b58\u50a8\u4e00\u4e9b\u601d\u8003, \u6240\u4ee5\u5c31\u8fd9\u4e48\u505a\u4e86","title":"\u5173\u4e8e"},{"location":"about/#_2","text":"\u5982\u679c\u89c9\u5f97\u5199\u7684\u4e0d\u597d, \u8bf7\u76f4\u63a5pull request\ud83d\udc7b \u5982\u679c\u89c9\u5f97\u6709\u5e2e\u52a9, \u90a3\u5f53\u7136\u662f\u975e\u5e38\u597d\u7684\u5566~","title":"\u5176\u4ed6"},{"location":"index_mm/","text":"\u6697\u9ed1\u6a21\u5f0f\u5207\u6362 \u00b6 \u9ed8\u8ba4\u4f7f\u7528 \\(dark\\ mode\\) , \u53ef\u4ee5\u901a\u8fc7\u5bfc\u822a\u680f\u6309\u94ae\u6765\u5207\u6362\u89c6\u56fe\u3002 \u8bbf\u95ee\u7f13\u6162 \u00b6 \u53ef\u4ee5\u66f4\u6362\u7f51\u5740: https://dicarbene.gitee.io/solutions \uff08\u53ef\u80fd\u5b58\u5728\u5185\u5bb9\u66f4\u65b0\u4e0d\u53ca\u65f6\u7684\u60c5\u51b5\uff09","title":"\u6742\u9879"},{"location":"index_mm/#_1","text":"\u9ed8\u8ba4\u4f7f\u7528 \\(dark\\ mode\\) , \u53ef\u4ee5\u901a\u8fc7\u5bfc\u822a\u680f\u6309\u94ae\u6765\u5207\u6362\u89c6\u56fe\u3002","title":"\u6697\u9ed1\u6a21\u5f0f\u5207\u6362"},{"location":"index_mm/#_2","text":"\u53ef\u4ee5\u66f4\u6362\u7f51\u5740: https://dicarbene.gitee.io/solutions \uff08\u53ef\u80fd\u5b58\u5728\u5185\u5bb9\u66f4\u65b0\u4e0d\u53ca\u65f6\u7684\u60c5\u51b5\uff09","title":"\u8bbf\u95ee\u7f13\u6162"},{"location":"resources_learn/","text":"\u8457\u540d\u7684\u677f\u5b50 \u00b6 Stanford University ICPC Team Notebook (2015-16) \u00b6 Download: https://cs.stanford.edu/group/acm/SLPC/notebook.pdf Theoretical Computer Science Cheat Sheet \u00b6 A robust math cheat-sheet. Download: https://www.tug.org/texshowcase/cheat.pdf KACTL, KTH 's ICPC team reference document \u00b6 It consists of 25 pages of copy-pasteable C++ code, for use in ICPC-style programming competitions. Repo: https://github.com/kth-competitive-programming/kactl Download: https://github.com/kth-competitive-programming/kactl/blob/master/kactl.pdf \u8457\u540d\u7684\u6559\u7a0b \u00b6 OI Wiki \u00b6 OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b (competitive programming) \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c\u5927\u5bb6\u53ef\u4ee5\u5728\u8fd9\u91cc\u83b7\u53d6\u4e0e\u7ade\u8d5b\u76f8\u5173\u7684\u3001\u6709\u8da3\u53c8\u5b9e\u7528\u7684\u77e5\u8bc6\u3002\u6211\u4eec\u4e3a\u5927\u5bb6\u51c6\u5907\u4e86\u7ade\u8d5b\u4e2d\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u5e38\u89c1\u9898\u578b\u3001\u89e3\u9898\u601d\u8def\u4ee5\u53ca\u5e38\u7528\u5de5\u5177\u7b49\u5185\u5bb9\uff0c\u5e2e\u52a9\u5927\u5bb6\u66f4\u5feb\u901f\u6df1\u5165\u5730\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u6d89\u53ca\u5230\u7684\u77e5\u8bc6\u3002 Url\uff1a https://oi-wiki.org/ \u5370\u5237\u8d28\u91cf\u7684 pdf \u7248\u672c\uff1a Repo: https://github.com/OI-wiki/OI-Wiki-export Releses: https://github.com/OI-wiki/OI-Wiki-export/releases E-Maxx Algorithms \u00b6 Source\uff1a http://e-maxx.ru/algo which provides descriptions of many algorithms and data structures especially popular in field of competitive programming. English Translate\uff1a https://cp-algorithms.com/ Solutions to Introduction to Algorithms Third Edition \u00b6 \ud83d\udcda A crowdsourced work contributed from nice people all around the world. Url\uff1a https://walkccc.me/CLRS/ All the good tutorials found for Competitive Programming\uff08Codeforces) \u00b6 list of some of the good tutorials written by codeforces users Url\uff1a https://codeforces.com/blog/entry/57282 Awesome Competitive Programming \u00b6 A curated list of awesome Competitive Programming , Algorithm and Data Structure resources. Repo: https://github.com/lnishan/awesome-competitive-programming","title":"Learning resources"},{"location":"resources_learn/#_1","text":"","title":"\u8457\u540d\u7684\u677f\u5b50"},{"location":"resources_learn/#stanford-university-icpc-team-notebook-2015-16","text":"Download: https://cs.stanford.edu/group/acm/SLPC/notebook.pdf","title":"Stanford University ICPC Team Notebook (2015-16)"},{"location":"resources_learn/#theoretical-computer-science-cheat-sheet","text":"A robust math cheat-sheet. Download: https://www.tug.org/texshowcase/cheat.pdf","title":"Theoretical Computer Science Cheat Sheet"},{"location":"resources_learn/#kactl-kths-icpc-team-reference-document","text":"It consists of 25 pages of copy-pasteable C++ code, for use in ICPC-style programming competitions. Repo: https://github.com/kth-competitive-programming/kactl Download: https://github.com/kth-competitive-programming/kactl/blob/master/kactl.pdf","title":"KACTL, KTH's ICPC team reference document"},{"location":"resources_learn/#_2","text":"","title":"\u8457\u540d\u7684\u6559\u7a0b"},{"location":"resources_learn/#oi-wiki","text":"OI Wiki \u81f4\u529b\u4e8e\u6210\u4e3a\u4e00\u4e2a\u514d\u8d39\u5f00\u653e\u4e14\u6301\u7eed\u66f4\u65b0\u7684 \u7f16\u7a0b\u7ade\u8d5b (competitive programming) \u77e5\u8bc6\u6574\u5408\u7ad9\u70b9\uff0c\u5927\u5bb6\u53ef\u4ee5\u5728\u8fd9\u91cc\u83b7\u53d6\u4e0e\u7ade\u8d5b\u76f8\u5173\u7684\u3001\u6709\u8da3\u53c8\u5b9e\u7528\u7684\u77e5\u8bc6\u3002\u6211\u4eec\u4e3a\u5927\u5bb6\u51c6\u5907\u4e86\u7ade\u8d5b\u4e2d\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u5e38\u89c1\u9898\u578b\u3001\u89e3\u9898\u601d\u8def\u4ee5\u53ca\u5e38\u7528\u5de5\u5177\u7b49\u5185\u5bb9\uff0c\u5e2e\u52a9\u5927\u5bb6\u66f4\u5feb\u901f\u6df1\u5165\u5730\u5b66\u4e60\u7f16\u7a0b\u7ade\u8d5b\u4e2d\u6d89\u53ca\u5230\u7684\u77e5\u8bc6\u3002 Url\uff1a https://oi-wiki.org/ \u5370\u5237\u8d28\u91cf\u7684 pdf \u7248\u672c\uff1a Repo: https://github.com/OI-wiki/OI-Wiki-export Releses: https://github.com/OI-wiki/OI-Wiki-export/releases","title":"OI Wiki"},{"location":"resources_learn/#e-maxx-algorithms","text":"Source\uff1a http://e-maxx.ru/algo which provides descriptions of many algorithms and data structures especially popular in field of competitive programming. English Translate\uff1a https://cp-algorithms.com/","title":"E-Maxx Algorithms"},{"location":"resources_learn/#solutions-to-introduction-to-algorithms-third-edition","text":"\ud83d\udcda A crowdsourced work contributed from nice people all around the world. Url\uff1a https://walkccc.me/CLRS/","title":"Solutions to Introduction to Algorithms Third Edition"},{"location":"resources_learn/#all-the-good-tutorials-found-for-competitive-programmingcodeforces","text":"list of some of the good tutorials written by codeforces users Url\uff1a https://codeforces.com/blog/entry/57282","title":"All the good tutorials found for Competitive Programming\uff08Codeforces)"},{"location":"resources_learn/#awesome-competitive-programming","text":"A curated list of awesome Competitive Programming , Algorithm and Data Structure resources. Repo: https://github.com/lnishan/awesome-competitive-programming","title":"Awesome Competitive Programming"},{"location":"resources_oj/","text":"OJ \u4ecb\u7ecd \u00b6 \u58f0\u660e \u00b6 \u4ec5\u4e3a\u4e2a\u4eba\u611f\u53d7 Codeforces \u00b6 A famous website for competitive programmers. \u5bf9\u4e8e\u7b97\u6cd5\u7ade\u8d5b\u9009\u624b\u6765\u8bf4\u5bb6\u55bb\u6237\u6653\u7684\u4e00\u4e2a\u7f51\u7ad9\uff0c\u8bad\u7ec3\u65f6\u6216\u591a\u6216\u5c11\u90fd\u4f1a\u7528\u5230\u7684\u4e00\u4e2a\u7f51\u7ad9\u3002Codeforces\u4e0arating\u5bf9\u5e94handle\u989c\u8272\u7684\u673a\u5236\u8ba9\u4eba\u53c8\u7231\u53c8\u6068\u3002\u60f3\u5feb\u901f\u627e\u5230\u6bd4\u8d5b\u7684\u624b\u611f\u5c31\u6765\u6253cf\u5427~ div1 \u51c6\u5907icpc\u6700\u7ec8\u9700\u8981\u51c6\u5907\u5230\u7684\u96be\u5ea6\u3002 div2 ab\u4e00\u822c\u4e3a\u7b7e\u5230\u601d\u7ef4\u9898\uff0c\u5957\u8def\u5f88\u591a\uff0c\u731c\u5bf9\u7ed3\u8bba\u53ef\u4ee5\u5f88\u5feb\u505a\u51fa\u3002\u6570\u636e\u7ed3\u6784\u4e00\u822c\u4e0d\u4f1a\u592a\u96be\uff0c\u4e3b\u8981\u8fd8\u662f\u5728\u4e8e\u7efc\u5408\u80fd\u529b\u7684\u53d1\u6325\u3002 div3 \u7528\u6765\u627e\u56de\u81ea\u4fe1\u3002 div4 \u6bd4div3\u8fd8\u8981\u7b80\u5355\uff0c \u4f46\u662f\u533a\u522b\u4e0d\u5927\u3002 \u666e\u901a\u573a\u6b21\u6309\u6bcf\u9898\u5206\u6570\u6392\u540d\uff0c\u6559\u80b2 (educational) \u573a\u6b21\u6309\u8fc7\u9898\u6570\u4e0e\u7f5a\u65f6\u6392\u540d\u3002 \u5728\u4e00\u573a\u6bd4\u8d5b\u524d\uff0c\u8fdb\u884c\u4e86\u63d0\u524d\u6ce8\u518c\u540e\uff0c\u53ef\u4ee5\u5728\u6bd4\u8d5b\u65f6\u5728\u4e3b\u7ad9\u56e0\u4e3a\u5404\u79cd\u539f\u56e0\u51fa\u73b0\u6545\u969c\u5bfc\u81f4\u4e0d\u53ef\u4f7f\u7528\u65f6\uff08\u5305\u62ec\u4e0d\u9650\u4e8e\uff1a\u4e3b\u7ad9\u6302\u4e86\u3001\u8bc4\u6d4b\u673a\u6302\u4e86\u3001\u8bc4\u6d4b\u961f\u5217\u70b8\u4e86\u7b49\u7b49\uff09\u53ef\u4ee5\u4f7f\u7528\u8f7b\u91cf\u7ea7\u7684\u526f\u7ad9\uff1a codeforces.m1 \u3001 codeforcesm2 \u3001 codeforces.m3 \u8bbf\u95ee\u7f13\u6162\u53ef\u4ee5\u4f7f\u7528ml\u955c\u50cf\u7ad9\uff08\u4f46\u662f\u4e3b\u7ad9\u5d29\u4e86\u955c\u50cf\u7ad9\u4e5f\u4e0d\u4e00\u5b9a\u597d\u4f7f\uff09\uff1a https://codeforces.ml/ Atcoder \u00b6 \u4e00\u4e2a\u77e5\u540d\u7684\u65e5\u672coj\uff0c\u7ecf\u5e38\u4e0eCodeforces\u540c\u65f6\u5217\u51fa\u3002 \u76f8\u8f83\u4e8ecodeforces\u6765\u8bf4\uff0c\u8bc4\u6d4b\u901f\u5ea6\u66f4\u5feb\uff0c\u9898\u9762\u66f4\u52a0\u7b80\u77ed\u4e00\u4e9b\u3002 \u666e\u901a\u573a\u6b21\u5206\u4e3a\u4e09\u79cd\uff0c\u6309\u96be\u5ea6\u6392\u5217 Atcoder Grand Contest \u76f8\u5f53\u4e8ecf-div1 Atcoder Regular Contest \u76f8\u5f53\u4e8ecf-div2 Atcoder Beginner Contest \u76f8\u5f53\u4e8ecf-div3 Virtual Judge \u00b6 \u77e5\u540d\u7684\u6574\u5408\u578boj\uff0c\u53ef\u4ee5\u5728\u4e0a\u9762\u5237\u8bb8\u591a\u77e5\u540doj\u7684\u9898\uff0c\u6bd4\u5982poj\u3001hdoj\u3001uva\u3001cf\u3001spoj\u7b49\u7b49\u3002 \u5176\u4e0a\u5305\u542b\u8457\u540d\u7684: \u201cKuangbin\u5e26\u4f60\u98de\u201d\u9898\u96c6\uff1a https://vjudge.net/article/187 \"\u5218\u6c5d\u4f73\u5927\u767d\u4e66\u9898\u5355\": https://vjudge.net/article/61 \"\u5218\u6c5d\u4f73\u7d2b\u4e66\u9898\u5355(\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178 \u7b2c\u4e8c\u7248 2014)\": https://vjudge.net/article/45 Nowcoder/\u725b\u5ba2 \u00b6 \u4e2d\u56fd\u7684\u77e5\u540doj\uff0c\u4e0eicpc\u8fdb\u884c\u4e86\u5408\u4f5c\u3002icpc/ccpc\u7684\u9898\u76ee\u53ef\u4ee5\u5728\u725b\u5ba2oj\u4e0a\u9762\u8fdb\u884c\u63d0\u4ea4\u3002 Luogu/\u6d1b\u8c37 \u00b6 \u5bf9\u4e8eoier\u5341\u5206\u719f\u6089\u7684oj\uff0cnoip\u6c1b\u56f4\u6d53\u539a\uff0c\u4e0d\u8fc7\u7531\u4e8e\u51fa\u8272\u7684\u4f7f\u7528\u4f53\u9a8c\u4ee5\u53ca\u4e30\u5bcc\u7684\u9898\u89e3\uff0c\u5728ACM\u7684\u51c6\u5907\u8fc7\u7a0b\u4e2d\u4ecd\u7136\u53ef\u4ee5\u4f7f\u7528\u3002 \u6d1b\u8c37\u8fd8\u53ef\u4ee5\u7528\u6765\u63d0\u4ea4uva\u4ee5\u53cacf\u7684\u9898\u76ee\uff0c\u4e0a\u9762\u8fd8\u6709\u6574\u7406\u597d\u7684usaco\u9898\u76ee\u7684\u5408\u96c6\u3002 Leetcode \u00b6 \u4e3b\u8981\u662f\u9762\u5411\u6c42\u804c\u627e\u5de5\u4f5c\u7684oj\uff0c\u7c7b\u4f3c\u7684\u8fd8\u6709 Lintcode \u3001 Hackerrank \u7528\u6765\u51c6\u5907ACM\u5e76\u4e0d\u592a\u9002\u5408\uff0c\u4f46\u662f\u5bf9\u4e8e\u638c\u63e1\u4e00\u4e9b\u57fa\u672c\u7684\u7b97\u6cd5\u6982\u5ff5\u4ee5\u53ca\u590d\u4e60\u6570\u636e\u7ed3\u6784\u8bfe\u7a0b\u8fd8\u662f\u633a\u597d\u7684\u3002 \u6bcf\u5468\u6709\u5468\u65e5\u8d5b\uff0c\u6bcf\u53cc\u5468\u5468\u516d\u665a\u6709\u53cc\u5468\u8d5b\u3002 Codechef \u00b6 \u4e00\u4e2a\u5728\u56fd\u5916\u77e5\u540d\u7684\u5370\u5ea6oj\uff0c\u4e3a\u56fd\u5916\u9009\u624b\u5e7f\u6cdb\u4f7f\u7528\u4ee5\u51c6\u5907icpc\u7684oj\u3002\u4e0a\u9762\u6709\u6bd4\u8f83\u4e30\u5bcc\u7684\u5b66\u4e60\u6307\u5bfc\u4e0e\u9898\u76ee\u8d44\u6e90\uff0c\u82f1\u6587\u597d\u7684\u540c\u5b66\u53ef\u4ee5\u524d\u53bb\u5b66\u4e60\u3002 SPOJ \u00b6 \u5916\u7f51\u77e5\u540d\u7684\u73b0\u4ee3oj\u4e4b\u4e00\u3002 Hackerrank \u00b6 \u7c7b\u4f3c\u4e8eleetcode\u7684\u4e00\u4e2aoj\uff0c\u9898\u76ee\u4ee3\u7801\u63d0\u4ea4\u65b9\u5f0f\u6bd4\u8f83\u81ea\u7531\u3002 USACO \u00b6 \u7f8e\u56fd\u9ad8\u4e2doier\u4f7f\u7528\u7684oj\uff0c\u5176\u4e2d\u7684\u9898\u96c6\u5e7f\u4e3a\u4eba\u77e5\u3002\u9875\u9762\u8f83\u8001\uff0c\u53ef\u4ee5\u9009\u62e9\u5728\u6d1b\u8c37\u4e0a\u9762\u63d0\u4ea4\u3002 Euler Project \u00b6 \u4ee5\u5404\u79cd\u6570\u5b66\u95ee\u9898\u586b\u7a7a\u9898\u7ec4\u6210\uff0c\u53ea\u9700\u8981\u63d0\u4ea4\u9898\u76ee\u7b54\u6848\u5373\u53ef\u3002 OJs that fit in just right in Vjudge \u00b6 poj \u9875\u9762\u8f83\u8001\uff0c\u627e\u9898\u4e0d\u592a\u65b9\u4fbf hdoj \u9875\u9762\u8f83\u8001\uff0c\u8d26\u53f7\u6ce8\u518c\u8f83\u7e41\u7410 uva \u7ecf\u5178oj\u4e4b\u4e00\uff0c\u5218\u6c5d\u4f73\u7684\u4e66\u4f7f\u7528\u7684oj\uff0c\u9875\u9762\u8f83\u8001\uff0c\u53ef\u4ee5\u4f7f\u7528udebug\u67e5\u8be2\u6570\u636e\u3002","title":"OJ introductions"},{"location":"resources_oj/#oj","text":"","title":"OJ \u4ecb\u7ecd"},{"location":"resources_oj/#_1","text":"\u4ec5\u4e3a\u4e2a\u4eba\u611f\u53d7","title":"\u58f0\u660e"},{"location":"resources_oj/#codeforces","text":"A famous website for competitive programmers. \u5bf9\u4e8e\u7b97\u6cd5\u7ade\u8d5b\u9009\u624b\u6765\u8bf4\u5bb6\u55bb\u6237\u6653\u7684\u4e00\u4e2a\u7f51\u7ad9\uff0c\u8bad\u7ec3\u65f6\u6216\u591a\u6216\u5c11\u90fd\u4f1a\u7528\u5230\u7684\u4e00\u4e2a\u7f51\u7ad9\u3002Codeforces\u4e0arating\u5bf9\u5e94handle\u989c\u8272\u7684\u673a\u5236\u8ba9\u4eba\u53c8\u7231\u53c8\u6068\u3002\u60f3\u5feb\u901f\u627e\u5230\u6bd4\u8d5b\u7684\u624b\u611f\u5c31\u6765\u6253cf\u5427~ div1 \u51c6\u5907icpc\u6700\u7ec8\u9700\u8981\u51c6\u5907\u5230\u7684\u96be\u5ea6\u3002 div2 ab\u4e00\u822c\u4e3a\u7b7e\u5230\u601d\u7ef4\u9898\uff0c\u5957\u8def\u5f88\u591a\uff0c\u731c\u5bf9\u7ed3\u8bba\u53ef\u4ee5\u5f88\u5feb\u505a\u51fa\u3002\u6570\u636e\u7ed3\u6784\u4e00\u822c\u4e0d\u4f1a\u592a\u96be\uff0c\u4e3b\u8981\u8fd8\u662f\u5728\u4e8e\u7efc\u5408\u80fd\u529b\u7684\u53d1\u6325\u3002 div3 \u7528\u6765\u627e\u56de\u81ea\u4fe1\u3002 div4 \u6bd4div3\u8fd8\u8981\u7b80\u5355\uff0c \u4f46\u662f\u533a\u522b\u4e0d\u5927\u3002 \u666e\u901a\u573a\u6b21\u6309\u6bcf\u9898\u5206\u6570\u6392\u540d\uff0c\u6559\u80b2 (educational) \u573a\u6b21\u6309\u8fc7\u9898\u6570\u4e0e\u7f5a\u65f6\u6392\u540d\u3002 \u5728\u4e00\u573a\u6bd4\u8d5b\u524d\uff0c\u8fdb\u884c\u4e86\u63d0\u524d\u6ce8\u518c\u540e\uff0c\u53ef\u4ee5\u5728\u6bd4\u8d5b\u65f6\u5728\u4e3b\u7ad9\u56e0\u4e3a\u5404\u79cd\u539f\u56e0\u51fa\u73b0\u6545\u969c\u5bfc\u81f4\u4e0d\u53ef\u4f7f\u7528\u65f6\uff08\u5305\u62ec\u4e0d\u9650\u4e8e\uff1a\u4e3b\u7ad9\u6302\u4e86\u3001\u8bc4\u6d4b\u673a\u6302\u4e86\u3001\u8bc4\u6d4b\u961f\u5217\u70b8\u4e86\u7b49\u7b49\uff09\u53ef\u4ee5\u4f7f\u7528\u8f7b\u91cf\u7ea7\u7684\u526f\u7ad9\uff1a codeforces.m1 \u3001 codeforcesm2 \u3001 codeforces.m3 \u8bbf\u95ee\u7f13\u6162\u53ef\u4ee5\u4f7f\u7528ml\u955c\u50cf\u7ad9\uff08\u4f46\u662f\u4e3b\u7ad9\u5d29\u4e86\u955c\u50cf\u7ad9\u4e5f\u4e0d\u4e00\u5b9a\u597d\u4f7f\uff09\uff1a https://codeforces.ml/","title":"Codeforces"},{"location":"resources_oj/#atcoder","text":"\u4e00\u4e2a\u77e5\u540d\u7684\u65e5\u672coj\uff0c\u7ecf\u5e38\u4e0eCodeforces\u540c\u65f6\u5217\u51fa\u3002 \u76f8\u8f83\u4e8ecodeforces\u6765\u8bf4\uff0c\u8bc4\u6d4b\u901f\u5ea6\u66f4\u5feb\uff0c\u9898\u9762\u66f4\u52a0\u7b80\u77ed\u4e00\u4e9b\u3002 \u666e\u901a\u573a\u6b21\u5206\u4e3a\u4e09\u79cd\uff0c\u6309\u96be\u5ea6\u6392\u5217 Atcoder Grand Contest \u76f8\u5f53\u4e8ecf-div1 Atcoder Regular Contest \u76f8\u5f53\u4e8ecf-div2 Atcoder Beginner Contest \u76f8\u5f53\u4e8ecf-div3","title":"Atcoder"},{"location":"resources_oj/#virtual-judge","text":"\u77e5\u540d\u7684\u6574\u5408\u578boj\uff0c\u53ef\u4ee5\u5728\u4e0a\u9762\u5237\u8bb8\u591a\u77e5\u540doj\u7684\u9898\uff0c\u6bd4\u5982poj\u3001hdoj\u3001uva\u3001cf\u3001spoj\u7b49\u7b49\u3002 \u5176\u4e0a\u5305\u542b\u8457\u540d\u7684: \u201cKuangbin\u5e26\u4f60\u98de\u201d\u9898\u96c6\uff1a https://vjudge.net/article/187 \"\u5218\u6c5d\u4f73\u5927\u767d\u4e66\u9898\u5355\": https://vjudge.net/article/61 \"\u5218\u6c5d\u4f73\u7d2b\u4e66\u9898\u5355(\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178 \u7b2c\u4e8c\u7248 2014)\": https://vjudge.net/article/45","title":"Virtual Judge"},{"location":"resources_oj/#nowcoder","text":"\u4e2d\u56fd\u7684\u77e5\u540doj\uff0c\u4e0eicpc\u8fdb\u884c\u4e86\u5408\u4f5c\u3002icpc/ccpc\u7684\u9898\u76ee\u53ef\u4ee5\u5728\u725b\u5ba2oj\u4e0a\u9762\u8fdb\u884c\u63d0\u4ea4\u3002","title":"Nowcoder/\u725b\u5ba2"},{"location":"resources_oj/#luogu","text":"\u5bf9\u4e8eoier\u5341\u5206\u719f\u6089\u7684oj\uff0cnoip\u6c1b\u56f4\u6d53\u539a\uff0c\u4e0d\u8fc7\u7531\u4e8e\u51fa\u8272\u7684\u4f7f\u7528\u4f53\u9a8c\u4ee5\u53ca\u4e30\u5bcc\u7684\u9898\u89e3\uff0c\u5728ACM\u7684\u51c6\u5907\u8fc7\u7a0b\u4e2d\u4ecd\u7136\u53ef\u4ee5\u4f7f\u7528\u3002 \u6d1b\u8c37\u8fd8\u53ef\u4ee5\u7528\u6765\u63d0\u4ea4uva\u4ee5\u53cacf\u7684\u9898\u76ee\uff0c\u4e0a\u9762\u8fd8\u6709\u6574\u7406\u597d\u7684usaco\u9898\u76ee\u7684\u5408\u96c6\u3002","title":"Luogu/\u6d1b\u8c37"},{"location":"resources_oj/#leetcode","text":"\u4e3b\u8981\u662f\u9762\u5411\u6c42\u804c\u627e\u5de5\u4f5c\u7684oj\uff0c\u7c7b\u4f3c\u7684\u8fd8\u6709 Lintcode \u3001 Hackerrank \u7528\u6765\u51c6\u5907ACM\u5e76\u4e0d\u592a\u9002\u5408\uff0c\u4f46\u662f\u5bf9\u4e8e\u638c\u63e1\u4e00\u4e9b\u57fa\u672c\u7684\u7b97\u6cd5\u6982\u5ff5\u4ee5\u53ca\u590d\u4e60\u6570\u636e\u7ed3\u6784\u8bfe\u7a0b\u8fd8\u662f\u633a\u597d\u7684\u3002 \u6bcf\u5468\u6709\u5468\u65e5\u8d5b\uff0c\u6bcf\u53cc\u5468\u5468\u516d\u665a\u6709\u53cc\u5468\u8d5b\u3002","title":"Leetcode"},{"location":"resources_oj/#codechef","text":"\u4e00\u4e2a\u5728\u56fd\u5916\u77e5\u540d\u7684\u5370\u5ea6oj\uff0c\u4e3a\u56fd\u5916\u9009\u624b\u5e7f\u6cdb\u4f7f\u7528\u4ee5\u51c6\u5907icpc\u7684oj\u3002\u4e0a\u9762\u6709\u6bd4\u8f83\u4e30\u5bcc\u7684\u5b66\u4e60\u6307\u5bfc\u4e0e\u9898\u76ee\u8d44\u6e90\uff0c\u82f1\u6587\u597d\u7684\u540c\u5b66\u53ef\u4ee5\u524d\u53bb\u5b66\u4e60\u3002","title":"Codechef"},{"location":"resources_oj/#spoj","text":"\u5916\u7f51\u77e5\u540d\u7684\u73b0\u4ee3oj\u4e4b\u4e00\u3002","title":"SPOJ"},{"location":"resources_oj/#hackerrank","text":"\u7c7b\u4f3c\u4e8eleetcode\u7684\u4e00\u4e2aoj\uff0c\u9898\u76ee\u4ee3\u7801\u63d0\u4ea4\u65b9\u5f0f\u6bd4\u8f83\u81ea\u7531\u3002","title":"Hackerrank"},{"location":"resources_oj/#usaco","text":"\u7f8e\u56fd\u9ad8\u4e2doier\u4f7f\u7528\u7684oj\uff0c\u5176\u4e2d\u7684\u9898\u96c6\u5e7f\u4e3a\u4eba\u77e5\u3002\u9875\u9762\u8f83\u8001\uff0c\u53ef\u4ee5\u9009\u62e9\u5728\u6d1b\u8c37\u4e0a\u9762\u63d0\u4ea4\u3002","title":"USACO"},{"location":"resources_oj/#euler-project","text":"\u4ee5\u5404\u79cd\u6570\u5b66\u95ee\u9898\u586b\u7a7a\u9898\u7ec4\u6210\uff0c\u53ea\u9700\u8981\u63d0\u4ea4\u9898\u76ee\u7b54\u6848\u5373\u53ef\u3002","title":"Euler Project"},{"location":"resources_oj/#ojs-that-fit-in-just-right-in-vjudge","text":"poj \u9875\u9762\u8f83\u8001\uff0c\u627e\u9898\u4e0d\u592a\u65b9\u4fbf hdoj \u9875\u9762\u8f83\u8001\uff0c\u8d26\u53f7\u6ce8\u518c\u8f83\u7e41\u7410 uva \u7ecf\u5178oj\u4e4b\u4e00\uff0c\u5218\u6c5d\u4f73\u7684\u4e66\u4f7f\u7528\u7684oj\uff0c\u9875\u9762\u8f83\u8001\uff0c\u53ef\u4ee5\u4f7f\u7528udebug\u67e5\u8be2\u6570\u636e\u3002","title":"OJs that fit in just right in Vjudge"},{"location":"solution_template/","text":"","title":"Solution template"},{"location":"cf/1000/","text":"","title":"Rating 1900"},{"location":"cf/1513/a/","text":"A. Array and Peaks \u00b6 Description A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. Given two integers n and k, construct a permutation a of numbers from 1 to n which has exactly k peaks. An index i of an array a of size n is said to be a peak if \\(1 < i < n\\) and \\(a_i \\gt a_{i-1}\\) and \\(a_i \\gt a_{i+1}\\) . If such permutation is not possible, then print -1. Input: \u00b6 The first line contains an integer \\(t\\) \\((1 \\leq t \\leq 100)\\) \u2014 the number of test cases. Then t lines follow, each containing two space-separated integers \\(n\\) \\((1 \\leq n \\leq 100)\\) and \\(k\\) \\((0 \\leq k \\leq n)\\) \u2014 the length of an array and the required number of peaks. Output: \u00b6 Output t lines. For each test case, if there is no permutation with given length and number of peaks, then print -1. Otherwise print a line containing n space-separated integers which forms a permutation of numbers from 1 to n and contains exactly k peaks. If there are multiple answers, print any. standard input \u00b6 5 1 0 5 2 6 6 2 1 6 1 standard output \u00b6 1 2 4 1 5 3 -1 -1 1 3 6 5 4 2 Note \u00b6 Note In the second test case of the example, we have array a = [2,4,1,5,3]. Here, indices i=2 and i=4 are the peaks of the array. This is because \\((a_{2} \\gt a_{1}, a_{2} \\gt a_{3})\\) and \\((a_{4} \\gt a_{3}, a_{4} \\gt a_{5})\\) .","title":"A. Array and Peaks"},{"location":"cf/1513/a/#a-array-and-peaks","text":"Description A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. Given two integers n and k, construct a permutation a of numbers from 1 to n which has exactly k peaks. An index i of an array a of size n is said to be a peak if \\(1 < i < n\\) and \\(a_i \\gt a_{i-1}\\) and \\(a_i \\gt a_{i+1}\\) . If such permutation is not possible, then print -1.","title":"A. Array and Peaks"},{"location":"cf/1513/a/#input","text":"The first line contains an integer \\(t\\) \\((1 \\leq t \\leq 100)\\) \u2014 the number of test cases. Then t lines follow, each containing two space-separated integers \\(n\\) \\((1 \\leq n \\leq 100)\\) and \\(k\\) \\((0 \\leq k \\leq n)\\) \u2014 the length of an array and the required number of peaks.","title":"Input:"},{"location":"cf/1513/a/#output","text":"Output t lines. For each test case, if there is no permutation with given length and number of peaks, then print -1. Otherwise print a line containing n space-separated integers which forms a permutation of numbers from 1 to n and contains exactly k peaks. If there are multiple answers, print any.","title":"Output:"},{"location":"cf/1513/a/#standard-input","text":"5 1 0 5 2 6 6 2 1 6 1","title":"standard input"},{"location":"cf/1513/a/#standard-output","text":"1 2 4 1 5 3 -1 -1 1 3 6 5 4 2","title":"standard output"},{"location":"cf/1513/a/#note","text":"Note In the second test case of the example, we have array a = [2,4,1,5,3]. Here, indices i=2 and i=4 are the peaks of the array. This is because \\((a_{2} \\gt a_{1}, a_{2} \\gt a_{3})\\) and \\((a_{4} \\gt a_{3}, a_{4} \\gt a_{5})\\) .","title":"Note"},{"location":"cf/1513/b/","text":"B. AND Sequences \u00b6 Description A sequence of n non-negative integers \\((n \\ge 2) a_1, a_2, \\dots, a_n\\) is called good if for all \\(i\\) from 1 to \\(n-1\\) the following condition holds true: \\(a_1 \\: \\& \\: a_2 \\: \\& \\: \\dots \\: \\& \\: a_i = a_{i+1} \\: \\& \\: a_{i+2} \\: \\& \\: \\dots \\: \\& \\: a_n,\\) where \\(\\&\\) denotes the bitwise AND operation . You are given an array a of size \\(n (n \\geq 2)\\) . Find the number of permutations p of numbers ranging from 1 to n, for which the sequence \\(a_{p_1}, a_{p_2}, ... ,a_{p_n}\\) is good. Since this number can be large, output it modulo \\(10^9+7\\) . Input: \u00b6 The first line contains a single integer \\(t\\) ( \\(1 \\leq t \\leq 10^4)\\) , denoting the number of test cases. The first line of each test case contains a single integer \\(n\\) \\((2 \\le n \\le 2 \\cdot 10^5)\\) \u2014 the size of the array. The second line of each test case contains \\(n\\) integers \\(a_1, a_2, \\ldots, a_n (0 \\le a_i \\le 10^9)\\) \u2014 the elements of the array. It is guaranteed that the sum of \\(n\\) over all test cases doesn't exceed \\(2 \\cdot 10^5\\) . Output: \u00b6 Output t lines, where the i-th line contains the number of good permutations in the i-th test case modulo 10^9 + 7. standard input \u00b6 4 3 1 1 1 5 1 2 3 4 5 5 0 2 0 3 0 4 1 3 5 1 standard output \u00b6 6 0 36 4 Note \u00b6 Note In the first test case, since all the numbers are equal, whatever permutation we take, the sequence is good. There are a total of 6 permutations possible with numbers from 1 to 3: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. In the second test case, it can be proved that no permutation exists for which the sequence is good. In the third test case, there are a total of 36 permutations for which the sequence is good. One of them is the permutation [1,5,4,2,3] which results in the sequence s=[0,0,3,2,0]. This is a good sequence because \\(s_1 = s_2 \\: \\& \\: s_3 \\: \\& \\: s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 = s_3 \\: \\& \\: s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 \\: \\& \\: s_3 = s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 \\: \\& \\: s_3 \\: \\& \\: s_4 = s_5 = 0\\) .","title":"B. AND Sequences"},{"location":"cf/1513/b/#b-and-sequences","text":"Description A sequence of n non-negative integers \\((n \\ge 2) a_1, a_2, \\dots, a_n\\) is called good if for all \\(i\\) from 1 to \\(n-1\\) the following condition holds true: \\(a_1 \\: \\& \\: a_2 \\: \\& \\: \\dots \\: \\& \\: a_i = a_{i+1} \\: \\& \\: a_{i+2} \\: \\& \\: \\dots \\: \\& \\: a_n,\\) where \\(\\&\\) denotes the bitwise AND operation . You are given an array a of size \\(n (n \\geq 2)\\) . Find the number of permutations p of numbers ranging from 1 to n, for which the sequence \\(a_{p_1}, a_{p_2}, ... ,a_{p_n}\\) is good. Since this number can be large, output it modulo \\(10^9+7\\) .","title":"B. AND Sequences"},{"location":"cf/1513/b/#input","text":"The first line contains a single integer \\(t\\) ( \\(1 \\leq t \\leq 10^4)\\) , denoting the number of test cases. The first line of each test case contains a single integer \\(n\\) \\((2 \\le n \\le 2 \\cdot 10^5)\\) \u2014 the size of the array. The second line of each test case contains \\(n\\) integers \\(a_1, a_2, \\ldots, a_n (0 \\le a_i \\le 10^9)\\) \u2014 the elements of the array. It is guaranteed that the sum of \\(n\\) over all test cases doesn't exceed \\(2 \\cdot 10^5\\) .","title":"Input:"},{"location":"cf/1513/b/#output","text":"Output t lines, where the i-th line contains the number of good permutations in the i-th test case modulo 10^9 + 7.","title":"Output:"},{"location":"cf/1513/b/#standard-input","text":"4 3 1 1 1 5 1 2 3 4 5 5 0 2 0 3 0 4 1 3 5 1","title":"standard input"},{"location":"cf/1513/b/#standard-output","text":"6 0 36 4","title":"standard output"},{"location":"cf/1513/b/#note","text":"Note In the first test case, since all the numbers are equal, whatever permutation we take, the sequence is good. There are a total of 6 permutations possible with numbers from 1 to 3: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. In the second test case, it can be proved that no permutation exists for which the sequence is good. In the third test case, there are a total of 36 permutations for which the sequence is good. One of them is the permutation [1,5,4,2,3] which results in the sequence s=[0,0,3,2,0]. This is a good sequence because \\(s_1 = s_2 \\: \\& \\: s_3 \\: \\& \\: s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 = s_3 \\: \\& \\: s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 \\: \\& \\: s_3 = s_4 \\: \\& \\: s_5 = 0\\) , \\(s_1 \\: \\& \\: s_2 \\: \\& \\: s_3 \\: \\& \\: s_4 = s_5 = 0\\) .","title":"Note"},{"location":"cf/1513/c/","text":"C. Add One \u00b6 Description You are given an integer \\(n\\) . You have to apply \\(m\\) operations to it. In a single operation, you must replace every digit d of the number with the decimal representation of integer d + 1. For example, 1912 becomes 21023 after applying the operation once. You have to find the length of \\(n\\) after applying m operations. Since the answer can be very large, print it modulo \\(10^9+7\\) . Input: \u00b6 The first line contains a single integer \\(t\\) \\((1 \\le t \\le 2 \\cdot 10^5)\\) \u2014 the number of test cases. The only line of each test case contains two integers \\(n\\) \\((1 \\le n \\le 10^9)\\) and \\(m\\) \\((1 \\le m \\le 2 \\cdot 10^5)\\) \u2014 the initial number and the number of operations. Output: \u00b6 For each test case output the length of the resulting number modulo \\(10^9+7\\) . standard input \u00b6 5 1 0 5 2 6 6 2 1 6 1 standard output \u00b6 1 2 4 1 5 3 -1 -1 1 3 6 5 4 2 Note \u00b6 Note For the first test, 1912 becomes 21023 after 1 operation which is of length 5. For the second test, 5 becomes 21 after 6 operations which is of length 2. For the third test, 999 becomes 101010 after 1 operation which is of length 6. For the fourth test, 88 becomes 1010 after 2 operations which is of length 4.","title":"C. Add One"},{"location":"cf/1513/c/#c-add-one","text":"Description You are given an integer \\(n\\) . You have to apply \\(m\\) operations to it. In a single operation, you must replace every digit d of the number with the decimal representation of integer d + 1. For example, 1912 becomes 21023 after applying the operation once. You have to find the length of \\(n\\) after applying m operations. Since the answer can be very large, print it modulo \\(10^9+7\\) .","title":"C. Add One"},{"location":"cf/1513/c/#input","text":"The first line contains a single integer \\(t\\) \\((1 \\le t \\le 2 \\cdot 10^5)\\) \u2014 the number of test cases. The only line of each test case contains two integers \\(n\\) \\((1 \\le n \\le 10^9)\\) and \\(m\\) \\((1 \\le m \\le 2 \\cdot 10^5)\\) \u2014 the initial number and the number of operations.","title":"Input:"},{"location":"cf/1513/c/#output","text":"For each test case output the length of the resulting number modulo \\(10^9+7\\) .","title":"Output:"},{"location":"cf/1513/c/#standard-input","text":"5 1 0 5 2 6 6 2 1 6 1","title":"standard input"},{"location":"cf/1513/c/#standard-output","text":"1 2 4 1 5 3 -1 -1 1 3 6 5 4 2","title":"standard output"},{"location":"cf/1513/c/#note","text":"Note For the first test, 1912 becomes 21023 after 1 operation which is of length 5. For the second test, 5 becomes 21 after 6 operations which is of length 2. For the third test, 999 becomes 101010 after 1 operation which is of length 6. For the fourth test, 88 becomes 1010 after 2 operations which is of length 4.","title":"Note"},{"location":"cf/1513/d/","text":"D. GCD and MST \u00b6 Description You are given an array a of \\(n\\) \\((n \\geq 2)\\) positive integers and an integer p. Consider an undirected weighted graph of n vertices numbered from 1 to n for which the edges between the vertices \\(i\\) and \\(j\\) \\((i<j)\\) are added in the following manner: If \\(gcd(a_i, a_{i+1}, a_{i+2}, \\dots, a_{j}) = min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)\\) , then there is an edge of weight \\(min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)\\) between i and j. If i+1=j, then there is an edge of weight p between i and j. Here \\(gcd(x, y, \\ldots)\\) denotes the greatest common divisor (GCD) of integers x, y, .... Note that there could be multiple edges between i and j if both of the above conditions are true, and if both the conditions fail for i and j, then there is no edge between these vertices. The goal is to find the weight of the minimum spanning tree of this graph. Input: \u00b6 The first line contains a single integer \\(t (1 \\leq t \\leq 10^4)\\) \u2014 the number of test cases. The first line of each test case contains two integers \\(n\\) \\((2 \\leq n \\leq 2 \\cdot 10^5)\\) and \\(p\\) \\((1 \\leq p \\leq 10^9)\\) \u2014 the number of nodes and the parameter \\(p\\) . The second line contains n integers \\(a_1, a_2, a_3, \\dots, a_n\\) \\((1 \\leq a_i \\leq 10^9)\\) . It is guaranteed that the sum of n over all test cases does not exceed \\(2 \\cdot 10^5\\) . Output: \u00b6 Output t lines. For each test case print the weight of the corresponding graph. standard input \u00b6 4 2 5 10 10 2 5 3 3 4 5 5 2 4 9 8 8 5 3 3 6 10 100 9 15 standard output \u00b6 5 3 12 46 Note \u00b6 Here are the graphs for the four test cases of the example (the edges of a possible MST of the graphs are marked pink): For test case 1 For test case 2 For test case 3 For test case 4","title":"D. GCD and MST"},{"location":"cf/1513/d/#d-gcd-and-mst","text":"Description You are given an array a of \\(n\\) \\((n \\geq 2)\\) positive integers and an integer p. Consider an undirected weighted graph of n vertices numbered from 1 to n for which the edges between the vertices \\(i\\) and \\(j\\) \\((i<j)\\) are added in the following manner: If \\(gcd(a_i, a_{i+1}, a_{i+2}, \\dots, a_{j}) = min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)\\) , then there is an edge of weight \\(min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)\\) between i and j. If i+1=j, then there is an edge of weight p between i and j. Here \\(gcd(x, y, \\ldots)\\) denotes the greatest common divisor (GCD) of integers x, y, .... Note that there could be multiple edges between i and j if both of the above conditions are true, and if both the conditions fail for i and j, then there is no edge between these vertices. The goal is to find the weight of the minimum spanning tree of this graph.","title":"D. GCD and MST"},{"location":"cf/1513/d/#input","text":"The first line contains a single integer \\(t (1 \\leq t \\leq 10^4)\\) \u2014 the number of test cases. The first line of each test case contains two integers \\(n\\) \\((2 \\leq n \\leq 2 \\cdot 10^5)\\) and \\(p\\) \\((1 \\leq p \\leq 10^9)\\) \u2014 the number of nodes and the parameter \\(p\\) . The second line contains n integers \\(a_1, a_2, a_3, \\dots, a_n\\) \\((1 \\leq a_i \\leq 10^9)\\) . It is guaranteed that the sum of n over all test cases does not exceed \\(2 \\cdot 10^5\\) .","title":"Input:"},{"location":"cf/1513/d/#output","text":"Output t lines. For each test case print the weight of the corresponding graph.","title":"Output:"},{"location":"cf/1513/d/#standard-input","text":"4 2 5 10 10 2 5 3 3 4 5 5 2 4 9 8 8 5 3 3 6 10 100 9 15","title":"standard input"},{"location":"cf/1513/d/#standard-output","text":"5 3 12 46","title":"standard output"},{"location":"cf/1513/d/#note","text":"Here are the graphs for the four test cases of the example (the edges of a possible MST of the graphs are marked pink): For test case 1 For test case 2 For test case 3 For test case 4","title":"Note"},{"location":"cf/1513/e/","text":"e","title":"E"},{"location":"cf/1513/f/","text":"","title":"F. Swapping Problem"},{"location":"icpc/kunming_2021_spring/a/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 A. AC \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Crystal's fortune predict system is successfully developed! The predict system is a distributed system consists of \\(N\\) computers. When it receives a predict request, each computer will generate one lowercase letter as its output. The final fortune predict result is determined by the concentration of all \\(N\\) outputs. Tired of getting bad predictions like awful: millions of bugs \\(awful:\\ millions\\ of\\ bugs\\) , Ben decides to hack into the predict system and modify the predict result. He has already got the access permission of every computer in the predict system, so he can modify their output to any letter arbitrarily. As Ben is going to take part in ICPC Asia Regional Kunming Site 2077, he wants predictions like suitable for writing \\(suitable\\ for\\ writing\\ codes\\) or will \\(get\\ accepted\\ for\\ every\\ problem\\) . He has found that the more times the substring \\(ac\\) occurs in the concentration of all \\(N\\) outputs, the luckier he will get in the contest. But as the contest is coming soon, he only has time to modify at most \\(K\\) outputs of the computers in the predict system. As Ben is busy hacking into the system, could you tell him how to get the most \\(ac\\) substrings after his modification? Input: \u00b6 The first line contains two integers \\(N\\) and \\(K\\) \\((1\u2264N\u22645\u00d710^5,0\u2264K\u2264N)\\) The second line contains a string of length \\(N\\) , denoting the origin prediction. It is guaranteed that the string consists of lowercase English letters. Output: \u00b6 Output two lines. The first line contains a single integer, denotes the maximum number of \\(ac\\) substring Bob can get, after his modification. The second line contains the final modified predict string. If there are multiple ways that results in the maximum number of \\(ac\\) substring, print any. standard input \u00b6 9 2 arakbacca standard output \u00b6 3 acacbacca","title":"Problem A. AC"},{"location":"icpc/kunming_2021_spring/a/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/a/#a-ac","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Crystal's fortune predict system is successfully developed! The predict system is a distributed system consists of \\(N\\) computers. When it receives a predict request, each computer will generate one lowercase letter as its output. The final fortune predict result is determined by the concentration of all \\(N\\) outputs. Tired of getting bad predictions like awful: millions of bugs \\(awful:\\ millions\\ of\\ bugs\\) , Ben decides to hack into the predict system and modify the predict result. He has already got the access permission of every computer in the predict system, so he can modify their output to any letter arbitrarily. As Ben is going to take part in ICPC Asia Regional Kunming Site 2077, he wants predictions like suitable for writing \\(suitable\\ for\\ writing\\ codes\\) or will \\(get\\ accepted\\ for\\ every\\ problem\\) . He has found that the more times the substring \\(ac\\) occurs in the concentration of all \\(N\\) outputs, the luckier he will get in the contest. But as the contest is coming soon, he only has time to modify at most \\(K\\) outputs of the computers in the predict system. As Ben is busy hacking into the system, could you tell him how to get the most \\(ac\\) substrings after his modification?","title":"A. AC"},{"location":"icpc/kunming_2021_spring/a/#input","text":"The first line contains two integers \\(N\\) and \\(K\\) \\((1\u2264N\u22645\u00d710^5,0\u2264K\u2264N)\\) The second line contains a string of length \\(N\\) , denoting the origin prediction. It is guaranteed that the string consists of lowercase English letters.","title":"Input:"},{"location":"icpc/kunming_2021_spring/a/#output","text":"Output two lines. The first line contains a single integer, denotes the maximum number of \\(ac\\) substring Bob can get, after his modification. The second line contains the final modified predict string. If there are multiple ways that results in the maximum number of \\(ac\\) substring, print any.","title":"Output:"},{"location":"icpc/kunming_2021_spring/a/#standard-input","text":"9 2 arakbacca","title":"standard input"},{"location":"icpc/kunming_2021_spring/a/#standard-output","text":"3 acacbacca","title":"standard output"},{"location":"icpc/kunming_2021_spring/b/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 B. Chessboard \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 2 seconds Memory limit: 256 megabytes Description Your are playing a computer game. The game is played on a chessboard of \\(n\\) rows and \\(m\\) columns. For each grid on the board, you can choose to put a black piece or a white piece on it, or leave it blank. Denote \\((i, j)\\) as the grid in the \\(i\\) -th row and the \\(j\\) -column. For each \\(i \\in[1, n], j \\in[1, m],\\) putting a black piece on \\((i, j)\\) earns you \\(s b_{i, j}\\) points, while a white piece earns you \\(s w_{i, j}\\) points, and leaving blank do not affect your score. The overall score will be the sum of the points earned by each piece. Note that a grid can contain at most one piece at the same time, that is, you cannot put a white piece and a black one simultaneously. It is guaranteed that \\(s b_{i, j}, s w_{i, j}\\) are all non-negative integers. After you finish placing the pieces, the computer program checks whether the pieces are put in a \\(beautiful\\) way or not. Let's define \\(b_{i}\\) as the number of black pieces in the \\(i\\) -th row, \\(B_{i}\\) as the number of black pieces in the \\(i\\) -th column, \\(w_{i}\\) as the number of white pieces in the \\(i\\) -th row, and \\(W_{i}\\) as the number of white pieces in the \\(i\\) -th column. The pieces are considered \\(beautiful\\) if For any \\(i \\in[1, n], b_{i}-w_{i} \\in\\left[l_{i}, r_{i}\\right]\\) holds. For any \\(i \\in[1, m], B_{i}-W_{i} \\in\\left[L_{i}, R_{i}\\right]\\) holds. Tired of high scores, you decide to minimize your score. To simplify the problem, you only need to output the minimum possible score among all beautiful placements of pieces. Input \u00b6 The first line of input contains two integers \\(n, m(2 \\leq n, m \\leq 50)\\) , denoting the number of rows and columns of the board. The next \\(n\\) lines describe the points earned by putting black pieces. The \\(i\\) -th of them contains \\(m\\) integers, the \\(j\\) -th of which denotes \\(s b_{i, j}\\left(0 \\leq s b_{i, j} \\leq 10^{3}\\right)\\) . The next \\(n\\) lines describe the points earned by putting white pieces. The \\(i\\) -th of them contains \\(m\\) integers, the \\(j\\) -th of which denotes \\(s w_{i, j}\\left(0 \\leq s w_{i, j} \\leq 10^{3}\\right)\\) . The next \\(n\\) lines describe the constraints on each row, the \\(i\\) -th of which contains two integers \\(l_{i}, r_{i}\\left(-m \\leq l_{i} \\leq r_{i} \\leq m\\right),\\) whose meaning can be found in the statement above. The next \\(m\\) lines describe the constraints on each column, the \\(i\\) -th of which contains two integers \\(L_{i}, R_{i}\\left(-n \\leq L_{i} \\leq R_{i} \\leq n\\right),\\) whose meaning can be found in the statement above. It is guaranteed that there exists at least one strategy that satisfies all the constraints. Output \u00b6 Output a single integer, denoting the minimum score you can get. standard input \u00b6 3 3 6 9 0 3 2 7 6 4 6 0 6 5 1 6 9 8 5 7 -3 -1 -3 0 1 3 0 0 1 1 -2 0 standard output \u00b6 9","title":"Problem B. Chessboard"},{"location":"icpc/kunming_2021_spring/b/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/b/#b-chessboard","text":"Constraint Input file: standard input Output file: standard output Time limit: 2 seconds Memory limit: 256 megabytes Description Your are playing a computer game. The game is played on a chessboard of \\(n\\) rows and \\(m\\) columns. For each grid on the board, you can choose to put a black piece or a white piece on it, or leave it blank. Denote \\((i, j)\\) as the grid in the \\(i\\) -th row and the \\(j\\) -column. For each \\(i \\in[1, n], j \\in[1, m],\\) putting a black piece on \\((i, j)\\) earns you \\(s b_{i, j}\\) points, while a white piece earns you \\(s w_{i, j}\\) points, and leaving blank do not affect your score. The overall score will be the sum of the points earned by each piece. Note that a grid can contain at most one piece at the same time, that is, you cannot put a white piece and a black one simultaneously. It is guaranteed that \\(s b_{i, j}, s w_{i, j}\\) are all non-negative integers. After you finish placing the pieces, the computer program checks whether the pieces are put in a \\(beautiful\\) way or not. Let's define \\(b_{i}\\) as the number of black pieces in the \\(i\\) -th row, \\(B_{i}\\) as the number of black pieces in the \\(i\\) -th column, \\(w_{i}\\) as the number of white pieces in the \\(i\\) -th row, and \\(W_{i}\\) as the number of white pieces in the \\(i\\) -th column. The pieces are considered \\(beautiful\\) if For any \\(i \\in[1, n], b_{i}-w_{i} \\in\\left[l_{i}, r_{i}\\right]\\) holds. For any \\(i \\in[1, m], B_{i}-W_{i} \\in\\left[L_{i}, R_{i}\\right]\\) holds. Tired of high scores, you decide to minimize your score. To simplify the problem, you only need to output the minimum possible score among all beautiful placements of pieces.","title":"B. Chessboard"},{"location":"icpc/kunming_2021_spring/b/#input","text":"The first line of input contains two integers \\(n, m(2 \\leq n, m \\leq 50)\\) , denoting the number of rows and columns of the board. The next \\(n\\) lines describe the points earned by putting black pieces. The \\(i\\) -th of them contains \\(m\\) integers, the \\(j\\) -th of which denotes \\(s b_{i, j}\\left(0 \\leq s b_{i, j} \\leq 10^{3}\\right)\\) . The next \\(n\\) lines describe the points earned by putting white pieces. The \\(i\\) -th of them contains \\(m\\) integers, the \\(j\\) -th of which denotes \\(s w_{i, j}\\left(0 \\leq s w_{i, j} \\leq 10^{3}\\right)\\) . The next \\(n\\) lines describe the constraints on each row, the \\(i\\) -th of which contains two integers \\(l_{i}, r_{i}\\left(-m \\leq l_{i} \\leq r_{i} \\leq m\\right),\\) whose meaning can be found in the statement above. The next \\(m\\) lines describe the constraints on each column, the \\(i\\) -th of which contains two integers \\(L_{i}, R_{i}\\left(-n \\leq L_{i} \\leq R_{i} \\leq n\\right),\\) whose meaning can be found in the statement above. It is guaranteed that there exists at least one strategy that satisfies all the constraints.","title":"Input"},{"location":"icpc/kunming_2021_spring/b/#output","text":"Output a single integer, denoting the minimum score you can get.","title":"Output"},{"location":"icpc/kunming_2021_spring/b/#standard-input","text":"3 3 6 9 0 3 2 7 6 4 6 0 6 5 1 6 9 8 5 7 -3 -1 -3 0 1 3 0 0 1 1 -2 0","title":"standard input"},{"location":"icpc/kunming_2021_spring/b/#standard-output","text":"9","title":"standard output"},{"location":"icpc/kunming_2021_spring/c/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 C. Cities \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 4 seconds Memory limit: 256 megabytes Description Bob lives in a chaotic country with \\(n\\) cities in a row, numbered from 1 to \\(n\\) . These cities are owned by different lords, and the \\(i\\) -th cities currently belongs to the \\(a_{i}\\) -th lord. To simply problems, we assume there are \\(n\\) lords in the country, and they are also numbered from 1 to \\(n\\) . Some lords may take control of multiple cities, while some new-born lords have not got any cities yet. Obviously, the greedy lords are not satisfied with the number of territories they have, so the country is constantly at war. Bob wants to change that, by making all the cities belong to the same lord! Bob can perform some magical operations to support his grand plan. With the help of each magic, Bob can do the following: Choose some cities with consecutive indices such that they belong to the same lord, and assign them to any other lord. As magics are really tiring, Bob wants to know the minimum number of such operations he needs to use to make all the cities belong to one lord. The following picture shows an example where \\(n=6\\) . Different shapes are used to represent cities belonging to different lords. As shown in the picture, the minimum number of magic operations used is 2. Input: \u00b6 The first line contains two integers \\(N\\) and \\(K\\) \\((1\u2264N\u22645\u00d710^5,0\u2264K\u2264N)\\) The second line contains a string of length \\(N\\) , denoting the origin prediction. It is guaranteed that the string consists of lowercase English letters. Output: \u00b6 The first line contains a single integer \\(t(1 \\leq t \\leq 160)-\\) the number of test cases. The first line of each test case contains an integers \\(n(1 \\leq n \\leq 5000)-\\) the number of cities in the country. The second line of each test case contains \\(n\\) integers \\(a_{i}\\left(1 \\leq a_{i} \\leq n\\right)-\\) the \\(i\\) -th city was originally owned by the \\(a_{i}\\) -th lord. It is guaranteed that currently no Lord will have more than 15 cities, which means no one \\(a_{i}\\) will appear more than 15 times in this line. It is guaranteed that the sum of \\(n\\) over all test cases doesn't exceed 6000 . standard input \u00b6 2 8 4 3 1 2 1 1 3 3 5 1 2 3 2 1 standard output\u200b \u00b6 3 2","title":"Problem C. Cities"},{"location":"icpc/kunming_2021_spring/c/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/c/#c-cities","text":"Constraint Input file: standard input Output file: standard output Time limit: 4 seconds Memory limit: 256 megabytes Description Bob lives in a chaotic country with \\(n\\) cities in a row, numbered from 1 to \\(n\\) . These cities are owned by different lords, and the \\(i\\) -th cities currently belongs to the \\(a_{i}\\) -th lord. To simply problems, we assume there are \\(n\\) lords in the country, and they are also numbered from 1 to \\(n\\) . Some lords may take control of multiple cities, while some new-born lords have not got any cities yet. Obviously, the greedy lords are not satisfied with the number of territories they have, so the country is constantly at war. Bob wants to change that, by making all the cities belong to the same lord! Bob can perform some magical operations to support his grand plan. With the help of each magic, Bob can do the following: Choose some cities with consecutive indices such that they belong to the same lord, and assign them to any other lord. As magics are really tiring, Bob wants to know the minimum number of such operations he needs to use to make all the cities belong to one lord. The following picture shows an example where \\(n=6\\) . Different shapes are used to represent cities belonging to different lords. As shown in the picture, the minimum number of magic operations used is 2.","title":"C. Cities"},{"location":"icpc/kunming_2021_spring/c/#input","text":"The first line contains two integers \\(N\\) and \\(K\\) \\((1\u2264N\u22645\u00d710^5,0\u2264K\u2264N)\\) The second line contains a string of length \\(N\\) , denoting the origin prediction. It is guaranteed that the string consists of lowercase English letters.","title":"Input:"},{"location":"icpc/kunming_2021_spring/c/#output","text":"The first line contains a single integer \\(t(1 \\leq t \\leq 160)-\\) the number of test cases. The first line of each test case contains an integers \\(n(1 \\leq n \\leq 5000)-\\) the number of cities in the country. The second line of each test case contains \\(n\\) integers \\(a_{i}\\left(1 \\leq a_{i} \\leq n\\right)-\\) the \\(i\\) -th city was originally owned by the \\(a_{i}\\) -th lord. It is guaranteed that currently no Lord will have more than 15 cities, which means no one \\(a_{i}\\) will appear more than 15 times in this line. It is guaranteed that the sum of \\(n\\) over all test cases doesn't exceed 6000 .","title":"Output:"},{"location":"icpc/kunming_2021_spring/c/#standard-input","text":"2 8 4 3 1 2 1 1 3 3 5 1 2 3 2 1","title":"standard input"},{"location":"icpc/kunming_2021_spring/c/#standard-output","text":"3 2","title":"standard output\u200b"},{"location":"icpc/kunming_2021_spring/d/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 D. Competition Against a Robot \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description As a tradition, the Code Village holds an annual championship, named ICPC (Intelligence Championship for Platinum Coders) to search for its most outstanding genius. The participants take part in various contests to find out who is the potential genius. The competitions include Go, Reversi, Sudoku and even Paper-Scissor-Rock, and it is fascinating to see the unpredictable result. Well... At least a few years ago. Everything changed when an AI robot came to the village - it seems weird, but as the name of the contest shows, anything related to 'intelligence' can take part freely. The robot soon won all the competitions without difficulty, and remained the defending champjon for years and years. Everyone considered it to be undefeatable. And this time, your task will be - as you have figured out - beat the robot! You are not alone - you will have a teammate. To make the game more interesting, the organizing committee has slightly modified the rule and it will be a guessing game. The game process is as follows: The judges announce two positive integers \\(n, k\\) to the three players - you, your teammate, and the robot. The robot generates an integer sequence of length \\(n\\) - let's call it \\(T\\) - and selects a secret integer \\(p \\in[0, n) .\\) Each element of \\(T\\) should fall in the range \\([0, k),\\) that is, each \\(T_{i}(0 \\leq i<n)\\) should be a non-negative integer and strictly less than \\(k\\) . Then it submits \\(T\\) and \\(p\\) to the judges. (Note that in this problem all the sequences are 0 -indexed.) You receive the sequence \\(T\\) and the number \\(p\\) from the judges, and your task is to tell the exact value of \\(p\\) to your teammate. To achieve that, you must select exactly one index \\(j \\in[0, n),\\) and set \\(T_{j}\\) to \\(\\left(T_{j}+1\\right) \\bmod k\\) Your teammate then receives the sequence \\(T\\) , and has to figure out the hidden integer \\(p\\) . Note that he doesn't have access to the original string generated by the robot; the only information he gets is the string that you write. He has only one chance to submit his answer, and if he succeeds, both of you win the game. Some typical settings may apply here. For example, the three of you all have unlimited and accurate memory, your team can discuss strategies before the game starts (of course NOT during the game), while the robot has the access to your strategy. You can also assume that the three of you will play optimally to achieve their goals: for you two the goal is definitely to win the game, while for the robot it will do its best to prevent your victory. Let's take some examples. For \\(n=1,\\) your team will definitely win by always answering \\(p=0 .\\) For \\(n=2, k=2,\\) a solution that ensures your victory works like this: your friend always answer the value of \\(T_{0},\\) and when you enter the room you just check if \\(T_{0}\\) differs from \\(p:\\) if so then choose \\(j=0,\\) otherwise choose \\(j=1 .\\) It is clear to see that such strategy works perfectly. However, it can be proved that for \\(n=3, k=2\\) your team has no chance to win at all. There are five hours left before the competition, and you decide to do some practice by writing a program to determine that for certain pair of \\((n, k),\\) which side will win the game. You will have to answer \\(Q\\) independent queries. Input: \u00b6 The first line of input contains an integer \\(Q\\left(1 \\leq Q \\leq 10^{5}\\right),\\) the number of queries you have to answer. Each of the next \\(Q\\) lines indicates a query. The \\(i\\) -th among them contains two integers \\(n_{i}, k_{i}\\left(1 \\leq n_{i}, k_{i} \\leq 10^{18}\\right),\\) denoting the \\(i\\) -th situation with parameters \\(n=n_{i}, k=k_{i} .\\) Recall that each query is independent. Output: \u00b6 Output \\(Q\\) lines, the \\(i\\) -th of which shows the winning side of the \\(i\\) -th situation. If your team is going towin, print a line of \\(HUMAN\\) ; otherwise display \\(ROBOT\\) . standard input \u00b6 3 1 10 2 2 3 2 standard output \u00b6 HUMAN HUMAN ROBOT","title":"Problem D. Competition Against a Robot"},{"location":"icpc/kunming_2021_spring/d/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/d/#d-competition-against-a-robot","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description As a tradition, the Code Village holds an annual championship, named ICPC (Intelligence Championship for Platinum Coders) to search for its most outstanding genius. The participants take part in various contests to find out who is the potential genius. The competitions include Go, Reversi, Sudoku and even Paper-Scissor-Rock, and it is fascinating to see the unpredictable result. Well... At least a few years ago. Everything changed when an AI robot came to the village - it seems weird, but as the name of the contest shows, anything related to 'intelligence' can take part freely. The robot soon won all the competitions without difficulty, and remained the defending champjon for years and years. Everyone considered it to be undefeatable. And this time, your task will be - as you have figured out - beat the robot! You are not alone - you will have a teammate. To make the game more interesting, the organizing committee has slightly modified the rule and it will be a guessing game. The game process is as follows: The judges announce two positive integers \\(n, k\\) to the three players - you, your teammate, and the robot. The robot generates an integer sequence of length \\(n\\) - let's call it \\(T\\) - and selects a secret integer \\(p \\in[0, n) .\\) Each element of \\(T\\) should fall in the range \\([0, k),\\) that is, each \\(T_{i}(0 \\leq i<n)\\) should be a non-negative integer and strictly less than \\(k\\) . Then it submits \\(T\\) and \\(p\\) to the judges. (Note that in this problem all the sequences are 0 -indexed.) You receive the sequence \\(T\\) and the number \\(p\\) from the judges, and your task is to tell the exact value of \\(p\\) to your teammate. To achieve that, you must select exactly one index \\(j \\in[0, n),\\) and set \\(T_{j}\\) to \\(\\left(T_{j}+1\\right) \\bmod k\\) Your teammate then receives the sequence \\(T\\) , and has to figure out the hidden integer \\(p\\) . Note that he doesn't have access to the original string generated by the robot; the only information he gets is the string that you write. He has only one chance to submit his answer, and if he succeeds, both of you win the game. Some typical settings may apply here. For example, the three of you all have unlimited and accurate memory, your team can discuss strategies before the game starts (of course NOT during the game), while the robot has the access to your strategy. You can also assume that the three of you will play optimally to achieve their goals: for you two the goal is definitely to win the game, while for the robot it will do its best to prevent your victory. Let's take some examples. For \\(n=1,\\) your team will definitely win by always answering \\(p=0 .\\) For \\(n=2, k=2,\\) a solution that ensures your victory works like this: your friend always answer the value of \\(T_{0},\\) and when you enter the room you just check if \\(T_{0}\\) differs from \\(p:\\) if so then choose \\(j=0,\\) otherwise choose \\(j=1 .\\) It is clear to see that such strategy works perfectly. However, it can be proved that for \\(n=3, k=2\\) your team has no chance to win at all. There are five hours left before the competition, and you decide to do some practice by writing a program to determine that for certain pair of \\((n, k),\\) which side will win the game. You will have to answer \\(Q\\) independent queries.","title":"D. Competition Against a Robot"},{"location":"icpc/kunming_2021_spring/d/#input","text":"The first line of input contains an integer \\(Q\\left(1 \\leq Q \\leq 10^{5}\\right),\\) the number of queries you have to answer. Each of the next \\(Q\\) lines indicates a query. The \\(i\\) -th among them contains two integers \\(n_{i}, k_{i}\\left(1 \\leq n_{i}, k_{i} \\leq 10^{18}\\right),\\) denoting the \\(i\\) -th situation with parameters \\(n=n_{i}, k=k_{i} .\\) Recall that each query is independent.","title":"Input:"},{"location":"icpc/kunming_2021_spring/d/#output","text":"Output \\(Q\\) lines, the \\(i\\) -th of which shows the winning side of the \\(i\\) -th situation. If your team is going towin, print a line of \\(HUMAN\\) ; otherwise display \\(ROBOT\\) .","title":"Output:"},{"location":"icpc/kunming_2021_spring/d/#standard-input","text":"3 1 10 2 2 3 2","title":"standard input"},{"location":"icpc/kunming_2021_spring/d/#standard-output","text":"HUMAN HUMAN ROBOT","title":"standard output"},{"location":"icpc/kunming_2021_spring/e/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 E. Counting Binary Trees \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 3 seconds Memory limit: 256 megabytes Description You are given an array of positive integers \\(k_{1}, k_{2}, \\ldots k_{m}\\) . A binary tree is special if all of these conditions are satisfied: A positive integer is written on every node of the tree. Every non-leaf node has both left child and right child, and the number written on it is equal to the product of numbers written on left child and right child. Here, we define a leaf as a node with no children, and a non-leaf node is a node that is not a leaf. The number written on any leaf is a multiple of at least one \\(k_{i}\\) . For two integers \\(x, y\\) , we consider \\(x\\) to be a multiple of \\(y\\) if there exists some integer \\(z\\) such that \\(x=y z\\) Two binary trees are different if one of these conditions is satisfied : The numbers written on their root are different. Their left subtrees are different or their right subtrees are different. Note that the definition above is recursive. For a given \\(n,\\) you need to find the number of special binary trees whose number written on the root is not greater than \\(n .\\) Since the answer can be quite large, output it modulo \\(998244353\\) . Input: \u00b6 The first line contains a single integer \\(T(1 \\leq T \\leq 10)-\\) the number of test cases. Then \\(T\\) test cases follow. The first line of each test case contains two integers \\(n, m\\left(2 \\leq n \\leq 10^{9}, 1 \\leq m \\leq 4\\right)\\) . The second line of each test case contains \\(m\\) integers \\(k_{1}, k_{2}, \\ldots, k_{m}\\left(2 \\leq k_{i} \\leq 100\\right)\\) . Output: \u00b6 For each test case, print a single integer: the number of special binary trees whose number written on theroot is not greater than \\(n\\) . Remember that you only need to print it modulo \\(998244353\\) . standard input \u00b6 2 6 2 2 3 100 2 6 9 standard output \u00b6 7 28 Note \u00b6 Note In the first test case, you can find: 1 special binary tree whose root is 2; 1 special binary tree whose root is 3; 2 special binary trees whose root is 4; 3 special binary trees whose root is 6. So the answer is 1 + 1 + 2 + 3 = 7. Here is an illustration for the 7 trees.","title":"Problem E. Counting Binary Trees"},{"location":"icpc/kunming_2021_spring/e/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/e/#e-counting-binary-trees","text":"Constraint Input file: standard input Output file: standard output Time limit: 3 seconds Memory limit: 256 megabytes Description You are given an array of positive integers \\(k_{1}, k_{2}, \\ldots k_{m}\\) . A binary tree is special if all of these conditions are satisfied: A positive integer is written on every node of the tree. Every non-leaf node has both left child and right child, and the number written on it is equal to the product of numbers written on left child and right child. Here, we define a leaf as a node with no children, and a non-leaf node is a node that is not a leaf. The number written on any leaf is a multiple of at least one \\(k_{i}\\) . For two integers \\(x, y\\) , we consider \\(x\\) to be a multiple of \\(y\\) if there exists some integer \\(z\\) such that \\(x=y z\\) Two binary trees are different if one of these conditions is satisfied : The numbers written on their root are different. Their left subtrees are different or their right subtrees are different. Note that the definition above is recursive. For a given \\(n,\\) you need to find the number of special binary trees whose number written on the root is not greater than \\(n .\\) Since the answer can be quite large, output it modulo \\(998244353\\) .","title":"E. Counting Binary Trees"},{"location":"icpc/kunming_2021_spring/e/#input","text":"The first line contains a single integer \\(T(1 \\leq T \\leq 10)-\\) the number of test cases. Then \\(T\\) test cases follow. The first line of each test case contains two integers \\(n, m\\left(2 \\leq n \\leq 10^{9}, 1 \\leq m \\leq 4\\right)\\) . The second line of each test case contains \\(m\\) integers \\(k_{1}, k_{2}, \\ldots, k_{m}\\left(2 \\leq k_{i} \\leq 100\\right)\\) .","title":"Input:"},{"location":"icpc/kunming_2021_spring/e/#output","text":"For each test case, print a single integer: the number of special binary trees whose number written on theroot is not greater than \\(n\\) . Remember that you only need to print it modulo \\(998244353\\) .","title":"Output:"},{"location":"icpc/kunming_2021_spring/e/#standard-input","text":"2 6 2 2 3 100 2 6 9","title":"standard input"},{"location":"icpc/kunming_2021_spring/e/#standard-output","text":"7 28","title":"standard output"},{"location":"icpc/kunming_2021_spring/e/#note","text":"Note In the first test case, you can find: 1 special binary tree whose root is 2; 1 special binary tree whose root is 3; 2 special binary trees whose root is 4; 3 special binary trees whose root is 6. So the answer is 1 + 1 + 2 + 3 = 7. Here is an illustration for the 7 trees.","title":"Note"},{"location":"icpc/kunming_2021_spring/f/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 F. Generating Strings \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 3 seconds Memory limit: 1024 megabytes Description \\(\\mathrm{Mr}\\) . Chaos is a high school student. Teachers always ask him to write a lot of compositions, but he isn't interested in it at all. Tired of generating meaningless words by himself, he invented a machine to help him. His teacher has posted the model article - string \\(S\\) , on the blackboard. His machine can generate any lowercase string \\(T\\) of length \\(n\\) at a time. For a fixed string \\(T,\\) the scoring method is simple: for any pair of integers \\([l, r]\\) such that the substring \\(T[l, r]\\) is a palindrome, the final score will be added by the number that \\(T[l, r]\\) occurs in \\(S\\) . Formally, let's define \\(T[l, r](1 \\leq l \\leq r \\leq n)\\) as the string \\(T_{l} T_{l+1} \\ldots T_{r},\\) a string is palindromic if it remains the same string when reversing, and the occurrence time of \\(P\\) in \\(S, \\mathrm{OCC}_{S}(P),\\) is the number of pairs of \\([l, r]\\) such that \\(S[l, r]=P .\\) Then, the value of \\(T,\\) namely \\(\\mathrm{V}(T),\\) is defined as \\[ \\mathrm{V}(T)=\\sum_{1 \\leq l \\leq r \\leq n, T[l, r] \\text { is palindromic }} \\text { OCC }_{S}(T[l, r]) \\] For example, given \\(S=\\) bbbaa, when the machine generated a string \\(T=\\) abbaabbaa, one of its palindromic substrings \\(P\\) will be bb. \\(\\mathrm{OCC}_{S}(P)\\) is 2 because bb occurs in \\(S\\) twice. Note that there are two bb in this case, and they are considered as different substrings and calculated twice. As Mr. Chao's best friend, you are asked to tell him the sum of value of all the \\(T\\) that his machine can generate. You accept this mission without thinking twice. However, it seems that you are getting into trouble, because the teacher makes \\(m\\) revisions on string \\(S .\\) Each time the last character will be deleted or a new character \\(c\\) will be added to the end. So now you have to answer the question for \\(m+1\\) times. Formally, let \\(\\mathcal{T}\\) be the set of all strings of length \\(n\\) that only contain lowercase English letters. You are going to calculate this formula \\[ \\sum_{T \\in \\mathcal{T}} \\mathrm{V}(T) \\] at the beginning and after each revision of \\(S,\\) that is, in total \\(m+1\\) times. As the answer may be too large, you only need to output its remainder modulo \\(10^{9}+7\\) Input: \u00b6 The first line contains one integer \\(t(1 \\leq t \\leq 25)-\\) the number of test cases. Then \\(t\\) test cases follow. The first line of each test case contains two integers and one string : \\(n, m, S\\left(1 \\leq n, m,|S| \\leq 5 \\times 10^{5}\\right)\\) the length of the string that machine can generate, the number of revision and the original article \\(S\\) . It is guaranteed that \\(S\\) only contain lowercase English letters. Each of the next \\(m\\) lines indicates a revision, in the order that they are made. The format will either be \\(1 c,\\) which means that the character \\(c\\) is added to the end of \\(S,\\) or \\(2,\\) which means that the last character of \\(S\\) is deleted. It is guaranteed that \\(c\\) is a lowercase English letter. It is guaranteed that in a single test file, the sum of \\(n\\) , the sum of \\(m\\) , and the sum of the length of \\(S\\) among all test cases do not exceed \\(2 \\times 10^{6}\\) . Output: \u00b6 For each test case print \\(m+ 1\\) lines, each containing a single integer. The first line should be the answer of the original \\(S\\) , while the next \\(m\\) lines should be the answer after each revision. Note that you only need to print them modulo \\(109 + 7\\) . standard input \u00b6 3 6 3 aaa 2 1 b 1 a 5 3 aabaaa 2 2 2 6 2 aababa 1 a 1 b standard output \u00b6 218504832 144861392 216149648 287508208 13924249 11567037 9211852 6924944 430225380 503798516 575088800","title":"Problem F. Generating Strings"},{"location":"icpc/kunming_2021_spring/f/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/f/#f-generating-strings","text":"Constraint Input file: standard input Output file: standard output Time limit: 3 seconds Memory limit: 1024 megabytes Description \\(\\mathrm{Mr}\\) . Chaos is a high school student. Teachers always ask him to write a lot of compositions, but he isn't interested in it at all. Tired of generating meaningless words by himself, he invented a machine to help him. His teacher has posted the model article - string \\(S\\) , on the blackboard. His machine can generate any lowercase string \\(T\\) of length \\(n\\) at a time. For a fixed string \\(T,\\) the scoring method is simple: for any pair of integers \\([l, r]\\) such that the substring \\(T[l, r]\\) is a palindrome, the final score will be added by the number that \\(T[l, r]\\) occurs in \\(S\\) . Formally, let's define \\(T[l, r](1 \\leq l \\leq r \\leq n)\\) as the string \\(T_{l} T_{l+1} \\ldots T_{r},\\) a string is palindromic if it remains the same string when reversing, and the occurrence time of \\(P\\) in \\(S, \\mathrm{OCC}_{S}(P),\\) is the number of pairs of \\([l, r]\\) such that \\(S[l, r]=P .\\) Then, the value of \\(T,\\) namely \\(\\mathrm{V}(T),\\) is defined as \\[ \\mathrm{V}(T)=\\sum_{1 \\leq l \\leq r \\leq n, T[l, r] \\text { is palindromic }} \\text { OCC }_{S}(T[l, r]) \\] For example, given \\(S=\\) bbbaa, when the machine generated a string \\(T=\\) abbaabbaa, one of its palindromic substrings \\(P\\) will be bb. \\(\\mathrm{OCC}_{S}(P)\\) is 2 because bb occurs in \\(S\\) twice. Note that there are two bb in this case, and they are considered as different substrings and calculated twice. As Mr. Chao's best friend, you are asked to tell him the sum of value of all the \\(T\\) that his machine can generate. You accept this mission without thinking twice. However, it seems that you are getting into trouble, because the teacher makes \\(m\\) revisions on string \\(S .\\) Each time the last character will be deleted or a new character \\(c\\) will be added to the end. So now you have to answer the question for \\(m+1\\) times. Formally, let \\(\\mathcal{T}\\) be the set of all strings of length \\(n\\) that only contain lowercase English letters. You are going to calculate this formula \\[ \\sum_{T \\in \\mathcal{T}} \\mathrm{V}(T) \\] at the beginning and after each revision of \\(S,\\) that is, in total \\(m+1\\) times. As the answer may be too large, you only need to output its remainder modulo \\(10^{9}+7\\)","title":"F. Generating Strings"},{"location":"icpc/kunming_2021_spring/f/#input","text":"The first line contains one integer \\(t(1 \\leq t \\leq 25)-\\) the number of test cases. Then \\(t\\) test cases follow. The first line of each test case contains two integers and one string : \\(n, m, S\\left(1 \\leq n, m,|S| \\leq 5 \\times 10^{5}\\right)\\) the length of the string that machine can generate, the number of revision and the original article \\(S\\) . It is guaranteed that \\(S\\) only contain lowercase English letters. Each of the next \\(m\\) lines indicates a revision, in the order that they are made. The format will either be \\(1 c,\\) which means that the character \\(c\\) is added to the end of \\(S,\\) or \\(2,\\) which means that the last character of \\(S\\) is deleted. It is guaranteed that \\(c\\) is a lowercase English letter. It is guaranteed that in a single test file, the sum of \\(n\\) , the sum of \\(m\\) , and the sum of the length of \\(S\\) among all test cases do not exceed \\(2 \\times 10^{6}\\) .","title":"Input:"},{"location":"icpc/kunming_2021_spring/f/#output","text":"For each test case print \\(m+ 1\\) lines, each containing a single integer. The first line should be the answer of the original \\(S\\) , while the next \\(m\\) lines should be the answer after each revision. Note that you only need to print them modulo \\(109 + 7\\) .","title":"Output:"},{"location":"icpc/kunming_2021_spring/f/#standard-input","text":"3 6 3 aaa 2 1 b 1 a 5 3 aabaaa 2 2 2 6 2 aababa 1 a 1 b","title":"standard input"},{"location":"icpc/kunming_2021_spring/f/#standard-output","text":"218504832 144861392 216149648 287508208 13924249 11567037 9211852 6924944 430225380 503798516 575088800","title":"standard output"},{"location":"icpc/kunming_2021_spring/g/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 G. Gift \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description EQWE is a pastry chef who has \\(N\\) friends. This year (obviously, the year 2021 ), he wants to give each friend a birthday cake made by himself. If EQWE wants to give the \\(i\\) -th friend a birthday cake made by himself, he need \\(c_{i}\\) days (do NOT need to be contiguous) before his friend's birthday to make it. After that he will get \\(v_{i}\\) favorable impression. Note that it will be OK for him to finish the cake exactly on the birthday, as birthday parties are always held at night. But EQWE doesn't have much time and he has another plan. There are \\(M\\) special gifts in the shop. EQWE can pay \\(a_{j}\\) yuan to get the \\(j\\) -th special gift and send it to any friend. Note that each gift is unique, which means that he can buy each gift at most once. After that he will get \\(b_{j}\\) favorable impression. EQWE's friends are very polite, so they do NOT want to receive more than one gift (including birthday cakes and special gifts). Note that to gain some favorable impression from a friend, the selected gift must be sent on the exact date of the friend's birthday. Suppose that it is the first day of the year 2021 now (and he can start making birthday cakes immediately), and EQWE has \\(W\\) yuan. What's the maximum number of favorable impression that EQWE can get in \\(2021 ?\\) Input: \u00b6 The input file starts with an integer \\(T(1 \\leq T \\leq 100)\\) , denoting the number of test cases. Then \\(T\\) test cases follow. For each test case, the first line contains three integers \\(N(1 \\leq N \\leq 500), M(1 \\leq M \\leq 15), W\\left(1 \\leq W \\leq 10^{4}\\right)\\) , denoting the number of friends, the number of special gifts, and the amount of money that EQWE has. Each of the following \\(N\\) lines describes a friend, in the format of year \\(-\\) month \\(-\\) day \\(c_{i} v_{i}\\) , where year \\(-\\) month \\(-\\) day is the date of the friend's birthday, \\(c_{i}\\left(1 \\leq c_{i} \\leq 30\\right)\\) is the day needed to make the birthday cake for the friend, and \\(v_{i}\\left(1 \\leq v_{i} \\leq 10^{6}\\right)\\) is the favorable impression that EQWE can get. It is guaranteed that \\(c_{i}, v_{i}\\) are integers. It is also guaranteed that the date given are all valid dates between the year 1990 and 2010 , that is, year is an integer between 1990 and \\(2010,\\) month is an integer between 1 and 12 , and day is a positive integer which do not exceed the number of days in the given month. The next \\(M\\) lines describe the special gifts, the \\(i\\) -th of which contain two inte The \\(i^{\\text {th }}\\) line is \\(a_{i} b_{i}\\left(1 \\leq a_{i} \\leq W, 1 \\leq b_{i} \\leq 10^{6}\\right)\\) Output: \u00b6 For each test case, output a line containing a single integer, denoting the maximum number of favorable impression that \\(EQWE\\) can get. standard input \u00b6 1 2 2 100 2000-01-01 10 13 2000-12-31 30 92 99 46 2 2 standard output \u00b6 138 Note \u00b6 Note It is commonly known that a year is divide into 12 months, and for the most of the time the numbers of days in each month are 31,28,31,30,31,30,31,31,30,31,30 and 31. The only exception is that for leap years the second month contains 29 days. Of the time range mentioned in the problem (that is, from 1990 to 2021), the leap years are 1992, 1996, 2000, 2004, 2008, 2012, 2016 and 2020.","title":"Problem G. Gift"},{"location":"icpc/kunming_2021_spring/g/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/g/#g-gift","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description EQWE is a pastry chef who has \\(N\\) friends. This year (obviously, the year 2021 ), he wants to give each friend a birthday cake made by himself. If EQWE wants to give the \\(i\\) -th friend a birthday cake made by himself, he need \\(c_{i}\\) days (do NOT need to be contiguous) before his friend's birthday to make it. After that he will get \\(v_{i}\\) favorable impression. Note that it will be OK for him to finish the cake exactly on the birthday, as birthday parties are always held at night. But EQWE doesn't have much time and he has another plan. There are \\(M\\) special gifts in the shop. EQWE can pay \\(a_{j}\\) yuan to get the \\(j\\) -th special gift and send it to any friend. Note that each gift is unique, which means that he can buy each gift at most once. After that he will get \\(b_{j}\\) favorable impression. EQWE's friends are very polite, so they do NOT want to receive more than one gift (including birthday cakes and special gifts). Note that to gain some favorable impression from a friend, the selected gift must be sent on the exact date of the friend's birthday. Suppose that it is the first day of the year 2021 now (and he can start making birthday cakes immediately), and EQWE has \\(W\\) yuan. What's the maximum number of favorable impression that EQWE can get in \\(2021 ?\\)","title":"G. Gift"},{"location":"icpc/kunming_2021_spring/g/#input","text":"The input file starts with an integer \\(T(1 \\leq T \\leq 100)\\) , denoting the number of test cases. Then \\(T\\) test cases follow. For each test case, the first line contains three integers \\(N(1 \\leq N \\leq 500), M(1 \\leq M \\leq 15), W\\left(1 \\leq W \\leq 10^{4}\\right)\\) , denoting the number of friends, the number of special gifts, and the amount of money that EQWE has. Each of the following \\(N\\) lines describes a friend, in the format of year \\(-\\) month \\(-\\) day \\(c_{i} v_{i}\\) , where year \\(-\\) month \\(-\\) day is the date of the friend's birthday, \\(c_{i}\\left(1 \\leq c_{i} \\leq 30\\right)\\) is the day needed to make the birthday cake for the friend, and \\(v_{i}\\left(1 \\leq v_{i} \\leq 10^{6}\\right)\\) is the favorable impression that EQWE can get. It is guaranteed that \\(c_{i}, v_{i}\\) are integers. It is also guaranteed that the date given are all valid dates between the year 1990 and 2010 , that is, year is an integer between 1990 and \\(2010,\\) month is an integer between 1 and 12 , and day is a positive integer which do not exceed the number of days in the given month. The next \\(M\\) lines describe the special gifts, the \\(i\\) -th of which contain two inte The \\(i^{\\text {th }}\\) line is \\(a_{i} b_{i}\\left(1 \\leq a_{i} \\leq W, 1 \\leq b_{i} \\leq 10^{6}\\right)\\)","title":"Input:"},{"location":"icpc/kunming_2021_spring/g/#output","text":"For each test case, output a line containing a single integer, denoting the maximum number of favorable impression that \\(EQWE\\) can get.","title":"Output:"},{"location":"icpc/kunming_2021_spring/g/#standard-input","text":"1 2 2 100 2000-01-01 10 13 2000-12-31 30 92 99 46 2 2","title":"standard input"},{"location":"icpc/kunming_2021_spring/g/#standard-output","text":"138","title":"standard output"},{"location":"icpc/kunming_2021_spring/g/#note","text":"Note It is commonly known that a year is divide into 12 months, and for the most of the time the numbers of days in each month are 31,28,31,30,31,30,31,31,30,31,30 and 31. The only exception is that for leap years the second month contains 29 days. Of the time range mentioned in the problem (that is, from 1990 to 2021), the leap years are 1992, 1996, 2000, 2004, 2008, 2012, 2016 and 2020.","title":"Note"},{"location":"icpc/kunming_2021_spring/h/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 H. Hard Calculation \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Hooray! It is the first time that Kunming holds an ICPC regional contest. Suppose that everything goes on well and the Kunming Regional Contest is held each year. In which year will the x-th Kunming Regional Contest be held? As Ben is going to take part in ICPC Asia Regional Kunming Site 2077, he wants predictions like suitable for writing \\(suitable\\ for\\ writing\\ codes\\) or will \\(get\\ accepted\\ for\\ every\\ problem\\) . He has found that the more times the substring \\(ac\\) occurs in the concentration of all \\(N\\) outputs, the luckier he will get in the contest. But as the contest is coming soon, he only has time to modify at most \\(K\\) outputs of the computers in the predict system. As Ben is busy hacking into the system, could you tell him how to get the most \\(ac\\) substrings after his modification? Input: \u00b6 The first and only line of input contains a single integer x(1 \u2264 x \u2264 100). Output: \u00b6 Output a single integer, denoting the year when the x-th Kunming Regional Contest will be held. standard input \u00b6 1 standard output \u00b6 2021 \u7b7e\u5230, \u7565\u8fc7\u3002","title":"Problem H. Hard Calculation"},{"location":"icpc/kunming_2021_spring/h/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/h/#h-hard-calculation","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Hooray! It is the first time that Kunming holds an ICPC regional contest. Suppose that everything goes on well and the Kunming Regional Contest is held each year. In which year will the x-th Kunming Regional Contest be held? As Ben is going to take part in ICPC Asia Regional Kunming Site 2077, he wants predictions like suitable for writing \\(suitable\\ for\\ writing\\ codes\\) or will \\(get\\ accepted\\ for\\ every\\ problem\\) . He has found that the more times the substring \\(ac\\) occurs in the concentration of all \\(N\\) outputs, the luckier he will get in the contest. But as the contest is coming soon, he only has time to modify at most \\(K\\) outputs of the computers in the predict system. As Ben is busy hacking into the system, could you tell him how to get the most \\(ac\\) substrings after his modification?","title":"H. Hard Calculation"},{"location":"icpc/kunming_2021_spring/h/#input","text":"The first and only line of input contains a single integer x(1 \u2264 x \u2264 100).","title":"Input:"},{"location":"icpc/kunming_2021_spring/h/#output","text":"Output a single integer, denoting the year when the x-th Kunming Regional Contest will be held.","title":"Output:"},{"location":"icpc/kunming_2021_spring/h/#standard-input","text":"1","title":"standard input"},{"location":"icpc/kunming_2021_spring/h/#standard-output","text":"2021 \u7b7e\u5230, \u7565\u8fc7\u3002","title":"standard output"},{"location":"icpc/kunming_2021_spring/i/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 I. Riichi!! \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Yui is a cute girl expert in a kind of Mahjong game. In case you are not familiar with the game, here we briefly introduce its rules. Mahjong is played with tiles , divided into 34 kinds . To simplify the problem, we assume that there is an infinite number of every kind (although in real-world game one kind usually contains up to 4 tiles). The 34 kinds of tiles can be further divided into 4 suites , named as \\(bing,\\ suo,\\ wan,\\ and\\ zi\\) . The \\(bing,\\ suo,\\ wan\\) have 9 kinds for each suite and \\(zi\\) tiles has only 7 kinds. Here are the all 34 kinds of tiles used in Mahjong game: Each row refers to a suite of tiles \\(suo,\\ bing,\\ wan,\\ zi\\) in order. Minor differences exist in various versions of Mahjong game, and here we only consider some basic rules. During the game, each player holds 13 tiles in hand. For each round, one player would draw one tile from the Mahjong table, then discard one tile from one of the 14 tiles owned at the time. A player wins the game if in a round he can create a special combination (defined below) with the 13 tiles in hand and 1 tiles drawn from table or discarded from other player. A special combination consists of 14 tiles, which can be divided into four kezi or shunzi, and an additional quetou. Here, kezi is a set of 3 identical tiles: And shunzi is a set of 3 continuous tiles (please aware that suite zi cannot form shunzi) : Finally, quetou is a pair of identical tiles: Here are some samples of special combinations: The second example might be confusing. Since you can combine your tiles arbitrary, the actual combination is the follows: If the player can obtain a special combination by getting some tile, then we call the player is in the Riichi status. In this status one can achieve victory once he/she gets the desired kind of tile! For example, the following sets of 13 tiles are in the Riichi status, the tiles after the space indicates the desired tiles to achieve victory. Now Yui is playing the Mahjong game. Sometimes she is very close to victory that if she tosses some tile she would reach the riichi status, while sometimes such tiles does not yet exist. And sometimes she has already got a winning hand of 14 tiles! To help you improve your Mahjong skills, Yui decides to give you a test. Now it is Yui\u2019s turn and she has 14 tiles in her hand. Please tell her which tile should be discarded in order to reach riichi status, or just tell her that she has already won in this round! Input: \u00b6 The input contains multiple tests cases. The first line includes a single integer \\(T-\\) the number of test cases. It is guaranteed that \\(T \\leq 10,000\\) . Each of the next \\(T\\) lines indicates a test case. It contains a string \\(s\\) of 28 characters, describing the 14 tiles that Yui currently has. For every \\(1 \\leq i \\leq 14\\) , the \\(i\\) -th tile obtained by Yui is described by the \\((2 i-1)\\) -th and \\(2 i\\) -th characters in the string: the former is a digit denoting the rank of the tile in its suite and the latter is one of \\(\\mathrm{w}, \\mathrm{b}, \\mathrm{s}, \\mathrm{z},\\) which means the suite wan, bing, suo and \\(\\mathrm{z}\\) i respectively. It is guaranteed that all the \\(s\\) in the input are valid and legal. Output: \u00b6 Output the answer for each test case separately. For each test case, if Yui has already reached the winning status in this round, output Tsumo! in a single line. Otherwise, output a single integer ans in a single line, the number of choices for discarding tiles to reach riichi status. Each of the next ans lines should indicate one way to reach the riichi status. It should start with two characters indicating the tile to be discarded. To prove that such way leads to a riichi status, you should print all the tiles that can lead to victory for the status. For clarity, print a space between the first two characters and the rest of the line. Important: Pay attention to the order when printing the desired tiles, as there is NO special judge. For tiles in different suites, print them in the order wan, bing, suo, zi (that is, always print wan tiles at first, and so on). For tiles in the same suite, print the cards in the ascending order of their digits (that is, the tile with smaller number goes first). Additionally, if there are several tiles available for a riichi status to achieve victory, you should also sort them in the same way. See the Sample Output for details. standard input \u00b6 5 1w2w3w4b5b6b7s8s9s1b1b1z2z6z 1w2w3w4b5b6b7s8s9s1b1b2z2z6z 1w2w3w4b5b6b7s8s9s1b1b2z2z2z 1b2b3b4b5b6b2s4s5s5s5s6s7s8s 1b1b1b2b3b4b5b6b7b8b9b9b9b1s standard output \u00b6 0 1 6z 1b2z Tsumo! 4 2s 3s4s6s9s 4s 2s 5s 3s 8s 3s 4 2b 1s 5b 1s 8b 1s 1s 1b2b3b4b5b6b7b8b9b Note The samples are the tiles below:","title":"Problem I. Riichi!!"},{"location":"icpc/kunming_2021_spring/i/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/i/#i-riichi","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Yui is a cute girl expert in a kind of Mahjong game. In case you are not familiar with the game, here we briefly introduce its rules. Mahjong is played with tiles , divided into 34 kinds . To simplify the problem, we assume that there is an infinite number of every kind (although in real-world game one kind usually contains up to 4 tiles). The 34 kinds of tiles can be further divided into 4 suites , named as \\(bing,\\ suo,\\ wan,\\ and\\ zi\\) . The \\(bing,\\ suo,\\ wan\\) have 9 kinds for each suite and \\(zi\\) tiles has only 7 kinds. Here are the all 34 kinds of tiles used in Mahjong game: Each row refers to a suite of tiles \\(suo,\\ bing,\\ wan,\\ zi\\) in order. Minor differences exist in various versions of Mahjong game, and here we only consider some basic rules. During the game, each player holds 13 tiles in hand. For each round, one player would draw one tile from the Mahjong table, then discard one tile from one of the 14 tiles owned at the time. A player wins the game if in a round he can create a special combination (defined below) with the 13 tiles in hand and 1 tiles drawn from table or discarded from other player. A special combination consists of 14 tiles, which can be divided into four kezi or shunzi, and an additional quetou. Here, kezi is a set of 3 identical tiles: And shunzi is a set of 3 continuous tiles (please aware that suite zi cannot form shunzi) : Finally, quetou is a pair of identical tiles: Here are some samples of special combinations: The second example might be confusing. Since you can combine your tiles arbitrary, the actual combination is the follows: If the player can obtain a special combination by getting some tile, then we call the player is in the Riichi status. In this status one can achieve victory once he/she gets the desired kind of tile! For example, the following sets of 13 tiles are in the Riichi status, the tiles after the space indicates the desired tiles to achieve victory. Now Yui is playing the Mahjong game. Sometimes she is very close to victory that if she tosses some tile she would reach the riichi status, while sometimes such tiles does not yet exist. And sometimes she has already got a winning hand of 14 tiles! To help you improve your Mahjong skills, Yui decides to give you a test. Now it is Yui\u2019s turn and she has 14 tiles in her hand. Please tell her which tile should be discarded in order to reach riichi status, or just tell her that she has already won in this round!","title":"I. Riichi!!"},{"location":"icpc/kunming_2021_spring/i/#input","text":"The input contains multiple tests cases. The first line includes a single integer \\(T-\\) the number of test cases. It is guaranteed that \\(T \\leq 10,000\\) . Each of the next \\(T\\) lines indicates a test case. It contains a string \\(s\\) of 28 characters, describing the 14 tiles that Yui currently has. For every \\(1 \\leq i \\leq 14\\) , the \\(i\\) -th tile obtained by Yui is described by the \\((2 i-1)\\) -th and \\(2 i\\) -th characters in the string: the former is a digit denoting the rank of the tile in its suite and the latter is one of \\(\\mathrm{w}, \\mathrm{b}, \\mathrm{s}, \\mathrm{z},\\) which means the suite wan, bing, suo and \\(\\mathrm{z}\\) i respectively. It is guaranteed that all the \\(s\\) in the input are valid and legal.","title":"Input:"},{"location":"icpc/kunming_2021_spring/i/#output","text":"Output the answer for each test case separately. For each test case, if Yui has already reached the winning status in this round, output Tsumo! in a single line. Otherwise, output a single integer ans in a single line, the number of choices for discarding tiles to reach riichi status. Each of the next ans lines should indicate one way to reach the riichi status. It should start with two characters indicating the tile to be discarded. To prove that such way leads to a riichi status, you should print all the tiles that can lead to victory for the status. For clarity, print a space between the first two characters and the rest of the line. Important: Pay attention to the order when printing the desired tiles, as there is NO special judge. For tiles in different suites, print them in the order wan, bing, suo, zi (that is, always print wan tiles at first, and so on). For tiles in the same suite, print the cards in the ascending order of their digits (that is, the tile with smaller number goes first). Additionally, if there are several tiles available for a riichi status to achieve victory, you should also sort them in the same way. See the Sample Output for details.","title":"Output:"},{"location":"icpc/kunming_2021_spring/i/#standard-input","text":"5 1w2w3w4b5b6b7s8s9s1b1b1z2z6z 1w2w3w4b5b6b7s8s9s1b1b2z2z6z 1w2w3w4b5b6b7s8s9s1b1b2z2z2z 1b2b3b4b5b6b2s4s5s5s5s6s7s8s 1b1b1b2b3b4b5b6b7b8b9b9b9b1s","title":"standard input"},{"location":"icpc/kunming_2021_spring/i/#standard-output","text":"0 1 6z 1b2z Tsumo! 4 2s 3s4s6s9s 4s 2s 5s 3s 8s 3s 4 2b 1s 5b 1s 8b 1s 1s 1b2b3b4b5b6b7b8b9b Note The samples are the tiles below:","title":"standard output"},{"location":"icpc/kunming_2021_spring/j/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 J. Mr. Main and Windmills \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Mr. Main took a train from city s to city t and passed a plain full of windmills. The train ran in a straight line. A windmill is a machine used for wind power generation. Its fan blades rotate when the wind blows. From his perspective, colorful windmills lined up on the horizon from left to right. As the train was running, the order of windmills from his perspective was constantly changing: a windmill was originally on the left/right of another, and then changed to its right/left; Given the coordinates of the windmills, please find the coordinate of him when he just observed the h-th windmill exchanged order with other windmills for the k-th times. It is guaranteed that any three of the points given, the cities and the windmills, were not collinear, and that all of the windmills were on the same side of the line that the train ran along. As shown in the picture, in Mr. Mian\u2019s perspective, B was initially to the left of A, and later to the right of A. Input: \u00b6 The first line of input contains two integers \\(n\\) and \\(m\\) , where \\(n(1 \\leq n \\leq 1000)\\) is number of windmills, and \\(m\\left(1 \\leq m \\leq 10^{4}\\right)\\) is number of queries. The second line contains four integers \\(x_{s}, y_{s}, x_{t}\\) and \\(y_{t}\\left(-10^{6} \\leq x_{s}, y_{s}, x_{t}, y_{t} \\leq 10^{6}\\right)\\) , which are the coordinates of the starting city \\(s\\) and destination city \\(t\\) . The next \\(n\\) lines describe the windmills, the \\(i\\) -th of which contains two integers \\(x_{i}, y_{i}\\left(-10^{6} \\leq x_{i}, y_{i} \\leq 10^{6}\\right)\\) , which are the coordinates of the \\(i\\) -th windmill. The next \\(m\\) lines describe the queries, the \\(i\\) -th of which contains two integers, \\(h_{i}\\) and \\(k_{i}\\) \\(\\left(1 \\leq h_{i} \\leq n, 1 \\leq k_{i} \\leq 10^{6}\\right)\\) , denoting a query for the coordinates when observing the \\(k_{i}\\) -th pass of the \\(h_{i}\\) -th windmill. Output: \u00b6 Output \\(m\\) lines, each containing two real numbers \\(x_{i}, y_{i}\\) , representing the coordinates when the \\(h_{i}\\) -th windmill is observed to exchange order with other windmills for \\(k\\) times; if it does not exist, output -1 . Your answer is considered correct if its absolute or relative error with the standard answer is less than \\(10^{-5}\\) standard input \u00b6 4 2 0 0 5 0 1 3 2 4 4 1 4 5 1 2 3 2 standard output \u00b6 -1 4.6666666667 0.0000000000","title":"Problem J. Mr. Main and Windmills"},{"location":"icpc/kunming_2021_spring/j/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/j/#j-mr-main-and-windmills","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description Mr. Main took a train from city s to city t and passed a plain full of windmills. The train ran in a straight line. A windmill is a machine used for wind power generation. Its fan blades rotate when the wind blows. From his perspective, colorful windmills lined up on the horizon from left to right. As the train was running, the order of windmills from his perspective was constantly changing: a windmill was originally on the left/right of another, and then changed to its right/left; Given the coordinates of the windmills, please find the coordinate of him when he just observed the h-th windmill exchanged order with other windmills for the k-th times. It is guaranteed that any three of the points given, the cities and the windmills, were not collinear, and that all of the windmills were on the same side of the line that the train ran along. As shown in the picture, in Mr. Mian\u2019s perspective, B was initially to the left of A, and later to the right of A.","title":"J. Mr. Main and Windmills"},{"location":"icpc/kunming_2021_spring/j/#input","text":"The first line of input contains two integers \\(n\\) and \\(m\\) , where \\(n(1 \\leq n \\leq 1000)\\) is number of windmills, and \\(m\\left(1 \\leq m \\leq 10^{4}\\right)\\) is number of queries. The second line contains four integers \\(x_{s}, y_{s}, x_{t}\\) and \\(y_{t}\\left(-10^{6} \\leq x_{s}, y_{s}, x_{t}, y_{t} \\leq 10^{6}\\right)\\) , which are the coordinates of the starting city \\(s\\) and destination city \\(t\\) . The next \\(n\\) lines describe the windmills, the \\(i\\) -th of which contains two integers \\(x_{i}, y_{i}\\left(-10^{6} \\leq x_{i}, y_{i} \\leq 10^{6}\\right)\\) , which are the coordinates of the \\(i\\) -th windmill. The next \\(m\\) lines describe the queries, the \\(i\\) -th of which contains two integers, \\(h_{i}\\) and \\(k_{i}\\) \\(\\left(1 \\leq h_{i} \\leq n, 1 \\leq k_{i} \\leq 10^{6}\\right)\\) , denoting a query for the coordinates when observing the \\(k_{i}\\) -th pass of the \\(h_{i}\\) -th windmill.","title":"Input:"},{"location":"icpc/kunming_2021_spring/j/#output","text":"Output \\(m\\) lines, each containing two real numbers \\(x_{i}, y_{i}\\) , representing the coordinates when the \\(h_{i}\\) -th windmill is observed to exchange order with other windmills for \\(k\\) times; if it does not exist, output -1 . Your answer is considered correct if its absolute or relative error with the standard answer is less than \\(10^{-5}\\)","title":"Output:"},{"location":"icpc/kunming_2021_spring/j/#standard-input","text":"4 2 0 0 5 0 1 3 2 4 4 1 4 5 1 2 3 2","title":"standard input"},{"location":"icpc/kunming_2021_spring/j/#standard-output","text":"-1 4.6666666667 0.0000000000","title":"standard output"},{"location":"icpc/kunming_2021_spring/k/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 K. Parallel Sort \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description As a master of parallel computing, schwer is recently considering about the method to achieve quick sorting on parallel computers. He needs your help! Given a permutation \\(\\left(p_{1}, \\cdots, p_{n}\\right),\\) you need to sort the permutation with minimum number of rounds. In a single round, one can take many pairs of integers \\(\\left(x_{1}, y_{1}\\right), \\cdots,\\left(x_{k}, y_{k}\\right)\\) as long as the values of \\(x_{1}, y_{1}, \\cdots, x_{k}, y_{k}\\) are pairwise distinct. Then with the help of \\(k\\) CPUs, for each \\(i \\in[1, k],\\) the value of \\(p_{x_{i}}\\) and \\(p_{y_{i}}\\) will be switched immediately. Note that a permutation \\(\\left(p_{1}, \\cdots, p_{n}\\right)\\) is sorted if for every integer \\(i \\in[1, n], p_{i}=i\\) holds. Take some examples. Assume that \\(n=4 .\\) For \\(p=(1,2,3,4),\\) the minimum number of round is 0 as it is already sorted. For \\(p=(4,3,2,1),\\) the answer is \\(1,\\) as you can swap the indices (1,4) and (2,3) simultaneously. Input: \u00b6 The first line of input contains a single integer \\(n\\left(1 \\leq n \\leq 10^{5}\\right)\\) , indicating the length of the permutation. The second line contains \\(n\\) integers \\(p_{1}, \\ldots, p_{n}\\left(1 \\leq p_{i} \\leq n\\right),\\) the given permutation. It is guaranteed that these integers form a permutation, that is, for every integer \\(i \\in[1, n]\\) there exists an unique integer \\(j \\in[1, n]\\) such that \\(p_{j}=i\\) Output: \u00b6 The first line of output should contain a single integer \\(m\\) , the minimum number of rounds to get the permutation sorted. Then print \\(m\\) line to show one possible solution. The \\(i\\) -th of the next \\(m\\) lines should describe the \\(i\\) -th round of your solution, beginning with a single integer \\(k\\) , and followed by \\(2 k\\) integers \\(x_{1}, y_{1} ; \\cdots ; x_{k}, y_{k}\\) . The constraints that \\(1 \\leq x_{i}, y_{i} \\leq n\\) and the \\(2 k\\) integers are pairwise distinct must be held. 1 standard input \u00b6 4 1 2 3 4 standard output \u00b6 0 2 standard input \u00b6 4 4 3 2 1 standard output \u00b6 1 2 1 4 2 3","title":"Problem K. Parallel Sort"},{"location":"icpc/kunming_2021_spring/k/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/k/#k-parallel-sort","text":"Constraint Input file: standard input Output file: standard output Time limit: 1 second Memory limit: 256 megabytes Description As a master of parallel computing, schwer is recently considering about the method to achieve quick sorting on parallel computers. He needs your help! Given a permutation \\(\\left(p_{1}, \\cdots, p_{n}\\right),\\) you need to sort the permutation with minimum number of rounds. In a single round, one can take many pairs of integers \\(\\left(x_{1}, y_{1}\\right), \\cdots,\\left(x_{k}, y_{k}\\right)\\) as long as the values of \\(x_{1}, y_{1}, \\cdots, x_{k}, y_{k}\\) are pairwise distinct. Then with the help of \\(k\\) CPUs, for each \\(i \\in[1, k],\\) the value of \\(p_{x_{i}}\\) and \\(p_{y_{i}}\\) will be switched immediately. Note that a permutation \\(\\left(p_{1}, \\cdots, p_{n}\\right)\\) is sorted if for every integer \\(i \\in[1, n], p_{i}=i\\) holds. Take some examples. Assume that \\(n=4 .\\) For \\(p=(1,2,3,4),\\) the minimum number of round is 0 as it is already sorted. For \\(p=(4,3,2,1),\\) the answer is \\(1,\\) as you can swap the indices (1,4) and (2,3) simultaneously.","title":"K. Parallel Sort"},{"location":"icpc/kunming_2021_spring/k/#input","text":"The first line of input contains a single integer \\(n\\left(1 \\leq n \\leq 10^{5}\\right)\\) , indicating the length of the permutation. The second line contains \\(n\\) integers \\(p_{1}, \\ldots, p_{n}\\left(1 \\leq p_{i} \\leq n\\right),\\) the given permutation. It is guaranteed that these integers form a permutation, that is, for every integer \\(i \\in[1, n]\\) there exists an unique integer \\(j \\in[1, n]\\) such that \\(p_{j}=i\\)","title":"Input:"},{"location":"icpc/kunming_2021_spring/k/#output","text":"The first line of output should contain a single integer \\(m\\) , the minimum number of rounds to get the permutation sorted. Then print \\(m\\) line to show one possible solution. The \\(i\\) -th of the next \\(m\\) lines should describe the \\(i\\) -th round of your solution, beginning with a single integer \\(k\\) , and followed by \\(2 k\\) integers \\(x_{1}, y_{1} ; \\cdots ; x_{k}, y_{k}\\) . The constraints that \\(1 \\leq x_{i}, y_{i} \\leq n\\) and the \\(2 k\\) integers are pairwise distinct must be held. 1","title":"Output:"},{"location":"icpc/kunming_2021_spring/k/#standard-input","text":"4 1 2 3 4","title":"standard input"},{"location":"icpc/kunming_2021_spring/k/#standard-output","text":"0 2","title":"standard output"},{"location":"icpc/kunming_2021_spring/k/#standard-input_1","text":"4 4 3 2 1","title":"standard input"},{"location":"icpc/kunming_2021_spring/k/#standard-output_1","text":"1 2 1 4 2 3","title":"standard output"},{"location":"icpc/kunming_2021_spring/l/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 L. Simone and Graph Coloring \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 2 seconds Memory limit: 512 megabytes Description Simone, a student of Graph Coloring University, is interested in permutation. Now she is given a permutation of length n, and she finds that if she connects each inverse pair, she will get a graph. Formally, for the given permutation, if \\(i < j and a_i > a_j\\) , then there will be an undirected edge between node \\(i\\) and node \\(j\\) in the graph. Then she wants to color this graph. Please achieve poor Simone\u2019s dream. To simplify the problem, you just need to find a way of coloring the vertices of the graph such that no two adjacent vertices are of the same color and minimize the number of colors used. Input: \u00b6 There are multiple test cases. The first line of the input contains an integer \\(T\\left(1 \\leq T \\leq 10^{6}\\right),\\) indicating the number of test cases. For each test case, the first line contains an integer \\(n\\left(1 \\leq n \\leq 10^{6}\\right),\\) indicating the length of the permutation. The second line contains \\(n\\) integers \\(a_{1}, a_{2}, \\ldots, a_{n},\\) indicating the permutation. It is guaranteed that the sum of \\(n\\) over all test cases does not exceed \\(10^{6}\\) . Output: \u00b6 For each test case, the first line contains an integer \\(c,\\) the chromatic number(the minimal number of colors been used when coloring) of the graph. The second line contapins \\(n\\) integers \\(c_{1}, c_{2}, \\ldots, c_{n},\\) the color of each node. Notice that \\(c_{i}\\) should satisfy the limit that \\(1 \\leq c_{i} \\leq c\\) If there are several answers, it is acceptable to print any of them. standard input \u00b6 2 4 1 3 4 2 2 1 2 standard output \u00b6 2 1 1 1 2 1 1 1","title":"Problem L. Simone and Graph Coloring"},{"location":"icpc/kunming_2021_spring/l/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/l/#l-simone-and-graph-coloring","text":"Constraint Input file: standard input Output file: standard output Time limit: 2 seconds Memory limit: 512 megabytes Description Simone, a student of Graph Coloring University, is interested in permutation. Now she is given a permutation of length n, and she finds that if she connects each inverse pair, she will get a graph. Formally, for the given permutation, if \\(i < j and a_i > a_j\\) , then there will be an undirected edge between node \\(i\\) and node \\(j\\) in the graph. Then she wants to color this graph. Please achieve poor Simone\u2019s dream. To simplify the problem, you just need to find a way of coloring the vertices of the graph such that no two adjacent vertices are of the same color and minimize the number of colors used.","title":"L. Simone and Graph Coloring"},{"location":"icpc/kunming_2021_spring/l/#input","text":"There are multiple test cases. The first line of the input contains an integer \\(T\\left(1 \\leq T \\leq 10^{6}\\right),\\) indicating the number of test cases. For each test case, the first line contains an integer \\(n\\left(1 \\leq n \\leq 10^{6}\\right),\\) indicating the length of the permutation. The second line contains \\(n\\) integers \\(a_{1}, a_{2}, \\ldots, a_{n},\\) indicating the permutation. It is guaranteed that the sum of \\(n\\) over all test cases does not exceed \\(10^{6}\\) .","title":"Input:"},{"location":"icpc/kunming_2021_spring/l/#output","text":"For each test case, the first line contains an integer \\(c,\\) the chromatic number(the minimal number of colors been used when coloring) of the graph. The second line contapins \\(n\\) integers \\(c_{1}, c_{2}, \\ldots, c_{n},\\) the color of each node. Notice that \\(c_{i}\\) should satisfy the limit that \\(1 \\leq c_{i} \\leq c\\) If there are several answers, it is acceptable to print any of them.","title":"Output:"},{"location":"icpc/kunming_2021_spring/l/#standard-input","text":"2 4 1 3 4 2 2 1 2","title":"standard input"},{"location":"icpc/kunming_2021_spring/l/#standard-output","text":"2 1 1 1 2 1 1 1","title":"standard output"},{"location":"icpc/kunming_2021_spring/m/","text":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a \u00b6 M. Stone Game \u00b6 Constraint Input file: standard input Output file: standard output Time limit: 4 seconds Memory limit: 1024 megabytes Description There are \\(n\\) piles of stones, the \\(i\\) -th of which contains \\(s_{i}\\) stones. The tiles are numbered from 1 to \\(n\\) . Rika and Satoko are playing a game on it. During each round of the game, Rika chooses some piles from all \\(n\\) piles. Let denote the set of all chosen piles as \\(S\\) . Satoko then writes a non-negative integer \\(x .\\) If Rika takes some piles from \\(S\\) with the number of stones among all the taken piles equal to \\(x\\) , she wins the game, while otherwise (Rika cannot find such piles) Satoko wins the game. Note that each tile can be taken at most once during a round, and it is possible that Rika does not pick up any tile (when \\(x=0\\) ). There are \\(Q\\) rounds of game in total, and for the \\(i\\) -th round of game Rika will let \\(S\\) be the set of all piles with index between \\(l_{i}\\) and \\(r_{i} .\\) For each round, Satoko wonders the minimum integer \\(x\\) she can write to win the game. As you are a master of programming, it is your turn to solve the problem! Input: \u00b6 The first line of input contains two integers \\(n\\) and \\(Q,\\) where \\(n\\left(1 \\leq n \\leq 10^{6}\\right)\\) is the number of tiles and \\(Q\\left(1 \\leq Q \\leq 10^{5}\\right)\\) is the number of the rounds of the games. The second line contains \\(n\\) integers \\(s_{1}, \\ldots, s_{n}\\) , the \\(i\\) -th of which, \\(s_{i}\\left(1 \\leq s_{i} \\leq 10^{9}\\right)\\) , indicates the number of stones in the tile with index \\(i\\) . Satoko wants you to compute the answers immediately after Rika chooses the interval, so she uses the following method to encrypt the input. The \\(i\\) -th of the next \\(Q\\) lines contains two integers \\(l_{i}^{\\prime}, r_{i}^{\\prime}\\left(1 \\leq l_{i}^{\\prime}, r_{i}^{\\prime} \\leq n\\right) .\\) The chosen index range for the \\(i\\) -th round, \\(l_{i}, r_{i},\\) can be computed by the following formula: \\(l_{i}=\\min \\left\\{\\left(l_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1,\\left(r_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1\\right\\}\\) \\(r_{i}=\\max \\left\\{\\left(l_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1,\\left(r_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1\\right\\}\\) where \\(a n s_{i}\\) denotes the answer for the \\(i\\) -th round of the game (and thus \\(a n s_{i-1}\\) is the answer for the previous round). You can assume that \\(a n s_{0}=0\\) . It is clear that under the given constraints, \\(1 \\leq l_{i} \\leq r_{i} \\leq n\\) holds. Output: \u00b6 Output \\(Q\\) lines, the \\(i\\) -th of which contains a single integer ans \\(_{i}\\) , denoting the minimum integer \\(x\\) Satoko can choose to win the \\(i\\) -th round of the game. standard input \u00b6 5 5 1 4 2 1 6 1 3 2 1 2 4 1 4 3 4 standard output \u00b6 8 15 4 9 4 Note In the example above, the actual query intervals are [2,4], [1,5], [3,5], [1,4] and [3,4].","title":"Problem M. Stone Game"},{"location":"icpc/kunming_2021_spring/m/#2021-icpc","text":"","title":"2021 ICPC \u6606\u660e\u9898\u89e3\u62a5\u544a"},{"location":"icpc/kunming_2021_spring/m/#m-stone-game","text":"Constraint Input file: standard input Output file: standard output Time limit: 4 seconds Memory limit: 1024 megabytes Description There are \\(n\\) piles of stones, the \\(i\\) -th of which contains \\(s_{i}\\) stones. The tiles are numbered from 1 to \\(n\\) . Rika and Satoko are playing a game on it. During each round of the game, Rika chooses some piles from all \\(n\\) piles. Let denote the set of all chosen piles as \\(S\\) . Satoko then writes a non-negative integer \\(x .\\) If Rika takes some piles from \\(S\\) with the number of stones among all the taken piles equal to \\(x\\) , she wins the game, while otherwise (Rika cannot find such piles) Satoko wins the game. Note that each tile can be taken at most once during a round, and it is possible that Rika does not pick up any tile (when \\(x=0\\) ). There are \\(Q\\) rounds of game in total, and for the \\(i\\) -th round of game Rika will let \\(S\\) be the set of all piles with index between \\(l_{i}\\) and \\(r_{i} .\\) For each round, Satoko wonders the minimum integer \\(x\\) she can write to win the game. As you are a master of programming, it is your turn to solve the problem!","title":"M. Stone Game"},{"location":"icpc/kunming_2021_spring/m/#input","text":"The first line of input contains two integers \\(n\\) and \\(Q,\\) where \\(n\\left(1 \\leq n \\leq 10^{6}\\right)\\) is the number of tiles and \\(Q\\left(1 \\leq Q \\leq 10^{5}\\right)\\) is the number of the rounds of the games. The second line contains \\(n\\) integers \\(s_{1}, \\ldots, s_{n}\\) , the \\(i\\) -th of which, \\(s_{i}\\left(1 \\leq s_{i} \\leq 10^{9}\\right)\\) , indicates the number of stones in the tile with index \\(i\\) . Satoko wants you to compute the answers immediately after Rika chooses the interval, so she uses the following method to encrypt the input. The \\(i\\) -th of the next \\(Q\\) lines contains two integers \\(l_{i}^{\\prime}, r_{i}^{\\prime}\\left(1 \\leq l_{i}^{\\prime}, r_{i}^{\\prime} \\leq n\\right) .\\) The chosen index range for the \\(i\\) -th round, \\(l_{i}, r_{i},\\) can be computed by the following formula: \\(l_{i}=\\min \\left\\{\\left(l_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1,\\left(r_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1\\right\\}\\) \\(r_{i}=\\max \\left\\{\\left(l_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1,\\left(r_{i}^{\\prime}+a n s_{i-1}\\right) \\bmod n+1\\right\\}\\) where \\(a n s_{i}\\) denotes the answer for the \\(i\\) -th round of the game (and thus \\(a n s_{i-1}\\) is the answer for the previous round). You can assume that \\(a n s_{0}=0\\) . It is clear that under the given constraints, \\(1 \\leq l_{i} \\leq r_{i} \\leq n\\) holds.","title":"Input:"},{"location":"icpc/kunming_2021_spring/m/#output","text":"Output \\(Q\\) lines, the \\(i\\) -th of which contains a single integer ans \\(_{i}\\) , denoting the minimum integer \\(x\\) Satoko can choose to win the \\(i\\) -th round of the game.","title":"Output:"},{"location":"icpc/kunming_2021_spring/m/#standard-input","text":"5 5 1 4 2 1 6 1 3 2 1 2 4 1 4 3 4","title":"standard input"},{"location":"icpc/kunming_2021_spring/m/#standard-output","text":"8 15 4 9 4 Note In the example above, the actual query intervals are [2,4], [1,5], [3,5], [1,4] and [3,4].","title":"standard output"},{"location":"mm/t1/","text":"","title":"USACO"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/","text":"\u8bd5\u9898\u7f16\u53f7\uff1a 201403-4 \u00b6 \u8bd5\u9898\u540d\u79f0\uff1a \u65e0\u7ebf\u7f51\u7edc \u00b6 \u65f6\u95f4\u9650\u5236\uff1a 1.0s \u00b6 \u5185\u5b58\u9650\u5236\uff1a 256.0MB \u00b6 \u95ee\u9898\u63cf\u8ff0 \u00b6 \u539f\u9898\u94fe\u63a5: http://118.190.20.162/view.page?gpid=T7 \u200b \u76ee\u524d\u5728\u4e00\u4e2a\u5f88\u5927\u7684\u5e73\u9762\u623f\u95f4\u91cc\u6709 n \u4e2a\u65e0\u7ebf\u8def\u7531\u5668,\u6bcf\u4e2a\u65e0\u7ebf\u8def\u7531\u5668\u90fd\u56fa\u5b9a\u5728\u67d0\u4e2a\u70b9\u4e0a\u3002\u4efb\u4f55\u4e24\u4e2a\u65e0\u7ebf\u8def\u7531\u5668\u53ea\u8981\u8ddd\u79bb\u4e0d\u8d85\u8fc7 r \u5c31\u80fd\u4e92\u76f8\u5efa\u7acb\u7f51\u7edc\u8fde\u63a5\u3002 \u3000\u3000\u9664\u6b64\u4ee5\u5916,\u53e6\u6709 m \u4e2a\u53ef\u4ee5\u6446\u653e\u65e0\u7ebf\u8def\u7531\u5668\u7684\u4f4d\u7f6e\u3002\u4f60\u53ef\u4ee5\u5728\u8fd9\u4e9b\u4f4d\u7f6e\u4e2d\u9009\u62e9\u81f3\u591a k \u4e2a\u589e\u8bbe\u65b0\u7684\u8def\u7531\u5668\u3002 \u3000\u3000\u4f60\u7684\u76ee\u6807\u662f\u4f7f\u5f97\u7b2c 1 \u4e2a\u8def\u7531\u5668\u548c\u7b2c 2 \u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u7684\u7f51\u7edc\u8fde\u63a5\u7ecf\u8fc7\u5c3d\u91cf\u5c11\u7684\u4e2d\u8f6c\u8def\u7531\u5668\u3002\u8bf7\u95ee\u5728\u6700\u4f18\u65b9\u6848\u4e0b\u4e2d\u8f6c\u8def\u7531\u5668\u7684\u6700\u5c11\u4e2a\u6570\u662f\u591a\u5c11? \u8f93\u5165\u683c\u5f0f \u00b6 \u200b \u7b2c\u4e00\u884c\u5305\u542b\u56db\u4e2a\u6b63\u6574\u6570 n,m,k,r\u3002(2 \u2264 n \u2264 100,1 \u2264 k \u2264 m \u2264 100, 1 \u2264 r \u2264 108)\u3002 \u3000\u3000\u63a5\u4e0b\u6765 n \u884c,\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 xi \u548c yi,\u8868\u793a\u4e00\u4e2a\u5df2\u7ecf\u653e\u7f6e\u597d\u7684\u65e0\u7ebf \u8def\u7531\u5668\u5728 (xi, yi) \u70b9\u5904\u3002\u8f93\u5165\u6570\u636e\u4fdd\u8bc1\u7b2c 1 \u548c\u7b2c 2 \u4e2a\u8def\u7531\u5668\u5728\u4ec5\u6709\u8fd9 n \u4e2a\u8def\u7531\u5668\u7684\u60c5\u51b5\u4e0b\u5df2\u7ecf\u53ef\u4ee5\u4e92\u76f8\u8fde\u63a5(\u7ecf\u8fc7\u4e00\u7cfb\u5217\u7684\u4e2d\u8f6c\u8def\u7531\u5668)\u3002 \u3000\u3000\u63a5\u4e0b\u6765 m \u884c,\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 xi \u548c yi,\u8868\u793a (xi, yi) \u70b9\u5904\u53ef\u4ee5\u589e\u8bbe \u4e00\u4e2a\u8def\u7531\u5668\u3002 \u3000\u3000\u8f93\u5165\u4e2d\u6240\u6709\u7684\u5750\u6807\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 108,\u4fdd\u8bc1\u8f93\u5165\u4e2d\u7684\u5750\u6807\u5404\u4e0d\u76f8\u540c\u3002 \u8f93\u51fa\u683c\u5f0f \u00b6 \u8f93\u51fa\u53ea\u6709\u4e00\u4e2a\u6570,\u5373\u5728\u6307\u5b9a\u7684\u4f4d\u7f6e\u4e2d\u589e\u8bbe k \u4e2a\u8def\u7531\u5668\u540e,\u4ece\u7b2c 1 \u4e2a\u8def \u7531\u5668\u5230\u7b2c 2 \u4e2a\u8def\u7531\u5668\u6700\u5c11\u7ecf\u8fc7\u7684\u4e2d\u8f6c\u8def\u7531\u5668\u7684\u4e2a\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 3 1 3 0 0 5 5 0 3 0 5 3 5 3 3 4 4 3 0 \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u601d\u8def \u00b6 \u8fd9\u9053\u9898\u76ee\u7684\u57fa\u7840\u662f\u901a\u8fc7\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5224\u65ad\u8282\u70b9\u4e4b\u95f4\u662f\u5426\u8fde\u901a\uff0c\u6c42\u51fa\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u6240\u9700\u7ecf\u8fc7\u7684\u6700\u5c0f\u4e2d\u8f6c\u6b21\u6570\u3002 \u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u662f\u56fe\u8bba\u5f53\u4e2d\u7684\u6c42\u4e24\u8282\u70b9\u4e4b\u95f4\u6700\u77ed\u8def\u5f84\u7684\u95ee\u9898\uff0c\u7b49\u540c\u4e8e\u5728\u6bcf\u5bf9\u76f4\u63a5\u8fde\u901a\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u957f\u5ea6\u4e3a1\u7684\u60c5\u51b5\u4e0b\uff08\u8fd9\u6837\u6c42\u51fa\u6700\u77ed\u8def\u5f84\u5c31\u7b49\u540c\u4e8e\u6c42\u51fa\u6700\u5c0f\u4e2d\u8f6c\u6b21\u6570\uff09\uff0c\u6c42\u51fa\u4e24\u8282\u70b9\u4e4b\u95f4\u6700\u77ed\u8def\u5f84\u7684\u95ee\u9898\u3002 \u7528\u7ed3\u6784\u4f53\u5b9a\u4e49\u6bcf\u4e2a\u8282\u70b9\uff0c\u7ed3\u6784\u4f53\u4e4b\u4e2d\u8bbe\u7f6e\u4e00\u4e2ak\u503c\u6765\u4ee3\u8868\u5f53\u904d\u5386\u5230\u5f53\u524d\u8282\u70b9\u65f6\u6240\u9009\u7684\u989d\u5916\u8282\u70b9\u7684\u6570\u76ee\uff0c\u901a\u8fc7\u8fd9\u4e2a\u6570\u76ee\u7684\u5927\u5c0f\u6765\u5224\u65ad\u4e0b\u4e00\u6b65\u5e94\u8be5\u5728\u4ec0\u4e48\u8303\u56f4\u7684\u8282\u70b9\u5185\u904d\u5386\u3002 AC\u4ee3\u7801 \u00b6 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define rep(z, x, y) for(int z=x;z<=y;++z) #define repd(z, x, y) for(int z=x;z>=y;--z) #define ft first #define sd second #define pb push_back const int maxn = 205 ; const int mod = 998244353 ; long long n , m , k , r , max1 = -1 ; bool vis [ maxn ]; using namespace std ; struct node { long long x , y , k ; int step ; node () { step = k = 0 ; } node ( int x1 , int y1 , int s1 , int k1 ) { x = x1 ; y = y1 ; step = s1 ; k = k1 ;} } mmp [ maxn ]; int bfs ( int beg , int ed ){ queue < node > Q ; Q . push ( node ( mmp [ beg ]. x , mmp [ beg ]. y , 0 , 0 )); vis [ beg ] = true ; while ( ! Q . empty ()) { node s = Q . front (); Q . pop (); if ( s . x == mmp [ ed ]. x && s . y == mmp [ ed ]. y ) return s . step - 1 ; //\u6c42\u51fa\u4e2d\u8f6c\u4e2a\u6570 if ( s . k == k ) max1 = n ; // \u5f53\u524dk\u503c\u4e00\u65e6\u5230\u8fbek\u65f6\u53ea\u80fd\u5728n\u91cc\u9762\u8d70\uff0c\u4e0d\u80fd\u7528mmp[n]\u4e4b\u5916\u7684\u8282\u70b9\u4e86 else max1 = n + m ; for ( int i = 1 ; i <= max1 ; ++ i ) { if ( vis [ i ]) continue ; if (( mmp [ i ]. x - s . x ) * ( mmp [ i ]. x - s . x ) + ( mmp [ i ]. y - s . y ) * ( mmp [ i ]. y - s . y ) > r * r ) continue ; //\u8ddd\u79bb\u4e0d\u591f\u5c31\u4e0d\u8d70 vis [ i ] = true ; int kk ; if ( i > n ) kk = s . k + 1 ; else kk = s . k ; //\u6839\u636e\u5f53\u524d\u8282\u70b9\u7684\u7c7b\u578b\u51b3\u5b9a\u662f\u5426\u52a0k\u503c Q . push ( node ( mmp [ i ]. x , mmp [ i ]. y , s . step + 1 , kk )); } } } int main () { cin >> n >> m >> k >> r ; rep ( i , 1 , n + m ) cin >> mmp [ i ]. x >> mmp [ i ]. y ; cout << bfs ( 1 , 2 ); //\u8f93\u5165\u7ed3\u679c return 0 ; }","title":"201403-4"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#201403-4","text":"","title":"\u8bd5\u9898\u7f16\u53f7\uff1a 201403-4"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_1","text":"","title":"\u8bd5\u9898\u540d\u79f0\uff1a \u65e0\u7ebf\u7f51\u7edc"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#10s","text":"","title":"\u65f6\u95f4\u9650\u5236\uff1a   1.0s"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#2560mb","text":"","title":"\u5185\u5b58\u9650\u5236\uff1a    256.0MB"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_2","text":"\u539f\u9898\u94fe\u63a5: http://118.190.20.162/view.page?gpid=T7 \u200b \u76ee\u524d\u5728\u4e00\u4e2a\u5f88\u5927\u7684\u5e73\u9762\u623f\u95f4\u91cc\u6709 n \u4e2a\u65e0\u7ebf\u8def\u7531\u5668,\u6bcf\u4e2a\u65e0\u7ebf\u8def\u7531\u5668\u90fd\u56fa\u5b9a\u5728\u67d0\u4e2a\u70b9\u4e0a\u3002\u4efb\u4f55\u4e24\u4e2a\u65e0\u7ebf\u8def\u7531\u5668\u53ea\u8981\u8ddd\u79bb\u4e0d\u8d85\u8fc7 r \u5c31\u80fd\u4e92\u76f8\u5efa\u7acb\u7f51\u7edc\u8fde\u63a5\u3002 \u3000\u3000\u9664\u6b64\u4ee5\u5916,\u53e6\u6709 m \u4e2a\u53ef\u4ee5\u6446\u653e\u65e0\u7ebf\u8def\u7531\u5668\u7684\u4f4d\u7f6e\u3002\u4f60\u53ef\u4ee5\u5728\u8fd9\u4e9b\u4f4d\u7f6e\u4e2d\u9009\u62e9\u81f3\u591a k \u4e2a\u589e\u8bbe\u65b0\u7684\u8def\u7531\u5668\u3002 \u3000\u3000\u4f60\u7684\u76ee\u6807\u662f\u4f7f\u5f97\u7b2c 1 \u4e2a\u8def\u7531\u5668\u548c\u7b2c 2 \u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u7684\u7f51\u7edc\u8fde\u63a5\u7ecf\u8fc7\u5c3d\u91cf\u5c11\u7684\u4e2d\u8f6c\u8def\u7531\u5668\u3002\u8bf7\u95ee\u5728\u6700\u4f18\u65b9\u6848\u4e0b\u4e2d\u8f6c\u8def\u7531\u5668\u7684\u6700\u5c11\u4e2a\u6570\u662f\u591a\u5c11?","title":"\u95ee\u9898\u63cf\u8ff0"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_3","text":"\u200b \u7b2c\u4e00\u884c\u5305\u542b\u56db\u4e2a\u6b63\u6574\u6570 n,m,k,r\u3002(2 \u2264 n \u2264 100,1 \u2264 k \u2264 m \u2264 100, 1 \u2264 r \u2264 108)\u3002 \u3000\u3000\u63a5\u4e0b\u6765 n \u884c,\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 xi \u548c yi,\u8868\u793a\u4e00\u4e2a\u5df2\u7ecf\u653e\u7f6e\u597d\u7684\u65e0\u7ebf \u8def\u7531\u5668\u5728 (xi, yi) \u70b9\u5904\u3002\u8f93\u5165\u6570\u636e\u4fdd\u8bc1\u7b2c 1 \u548c\u7b2c 2 \u4e2a\u8def\u7531\u5668\u5728\u4ec5\u6709\u8fd9 n \u4e2a\u8def\u7531\u5668\u7684\u60c5\u51b5\u4e0b\u5df2\u7ecf\u53ef\u4ee5\u4e92\u76f8\u8fde\u63a5(\u7ecf\u8fc7\u4e00\u7cfb\u5217\u7684\u4e2d\u8f6c\u8def\u7531\u5668)\u3002 \u3000\u3000\u63a5\u4e0b\u6765 m \u884c,\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 xi \u548c yi,\u8868\u793a (xi, yi) \u70b9\u5904\u53ef\u4ee5\u589e\u8bbe \u4e00\u4e2a\u8def\u7531\u5668\u3002 \u3000\u3000\u8f93\u5165\u4e2d\u6240\u6709\u7684\u5750\u6807\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 108,\u4fdd\u8bc1\u8f93\u5165\u4e2d\u7684\u5750\u6807\u5404\u4e0d\u76f8\u540c\u3002","title":"\u8f93\u5165\u683c\u5f0f"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_4","text":"\u8f93\u51fa\u53ea\u6709\u4e00\u4e2a\u6570,\u5373\u5728\u6307\u5b9a\u7684\u4f4d\u7f6e\u4e2d\u589e\u8bbe k \u4e2a\u8def\u7531\u5668\u540e,\u4ece\u7b2c 1 \u4e2a\u8def \u7531\u5668\u5230\u7b2c 2 \u4e2a\u8def\u7531\u5668\u6700\u5c11\u7ecf\u8fc7\u7684\u4e2d\u8f6c\u8def\u7531\u5668\u7684\u4e2a\u6570\u3002","title":"\u8f93\u51fa\u683c\u5f0f"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_5","text":"5 3 1 3 0 0 5 5 0 3 0 5 3 5 3 3 4 4 3 0","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_6","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#_7","text":"\u8fd9\u9053\u9898\u76ee\u7684\u57fa\u7840\u662f\u901a\u8fc7\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5224\u65ad\u8282\u70b9\u4e4b\u95f4\u662f\u5426\u8fde\u901a\uff0c\u6c42\u51fa\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u6240\u9700\u7ecf\u8fc7\u7684\u6700\u5c0f\u4e2d\u8f6c\u6b21\u6570\u3002 \u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u662f\u56fe\u8bba\u5f53\u4e2d\u7684\u6c42\u4e24\u8282\u70b9\u4e4b\u95f4\u6700\u77ed\u8def\u5f84\u7684\u95ee\u9898\uff0c\u7b49\u540c\u4e8e\u5728\u6bcf\u5bf9\u76f4\u63a5\u8fde\u901a\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u957f\u5ea6\u4e3a1\u7684\u60c5\u51b5\u4e0b\uff08\u8fd9\u6837\u6c42\u51fa\u6700\u77ed\u8def\u5f84\u5c31\u7b49\u540c\u4e8e\u6c42\u51fa\u6700\u5c0f\u4e2d\u8f6c\u6b21\u6570\uff09\uff0c\u6c42\u51fa\u4e24\u8282\u70b9\u4e4b\u95f4\u6700\u77ed\u8def\u5f84\u7684\u95ee\u9898\u3002 \u7528\u7ed3\u6784\u4f53\u5b9a\u4e49\u6bcf\u4e2a\u8282\u70b9\uff0c\u7ed3\u6784\u4f53\u4e4b\u4e2d\u8bbe\u7f6e\u4e00\u4e2ak\u503c\u6765\u4ee3\u8868\u5f53\u904d\u5386\u5230\u5f53\u524d\u8282\u70b9\u65f6\u6240\u9009\u7684\u989d\u5916\u8282\u70b9\u7684\u6570\u76ee\uff0c\u901a\u8fc7\u8fd9\u4e2a\u6570\u76ee\u7684\u5927\u5c0f\u6765\u5224\u65ad\u4e0b\u4e00\u6b65\u5e94\u8be5\u5728\u4ec0\u4e48\u8303\u56f4\u7684\u8282\u70b9\u5185\u904d\u5386\u3002","title":"\u601d\u8def"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A%20201403-4/#ac","text":"#pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define rep(z, x, y) for(int z=x;z<=y;++z) #define repd(z, x, y) for(int z=x;z>=y;--z) #define ft first #define sd second #define pb push_back const int maxn = 205 ; const int mod = 998244353 ; long long n , m , k , r , max1 = -1 ; bool vis [ maxn ]; using namespace std ; struct node { long long x , y , k ; int step ; node () { step = k = 0 ; } node ( int x1 , int y1 , int s1 , int k1 ) { x = x1 ; y = y1 ; step = s1 ; k = k1 ;} } mmp [ maxn ]; int bfs ( int beg , int ed ){ queue < node > Q ; Q . push ( node ( mmp [ beg ]. x , mmp [ beg ]. y , 0 , 0 )); vis [ beg ] = true ; while ( ! Q . empty ()) { node s = Q . front (); Q . pop (); if ( s . x == mmp [ ed ]. x && s . y == mmp [ ed ]. y ) return s . step - 1 ; //\u6c42\u51fa\u4e2d\u8f6c\u4e2a\u6570 if ( s . k == k ) max1 = n ; // \u5f53\u524dk\u503c\u4e00\u65e6\u5230\u8fbek\u65f6\u53ea\u80fd\u5728n\u91cc\u9762\u8d70\uff0c\u4e0d\u80fd\u7528mmp[n]\u4e4b\u5916\u7684\u8282\u70b9\u4e86 else max1 = n + m ; for ( int i = 1 ; i <= max1 ; ++ i ) { if ( vis [ i ]) continue ; if (( mmp [ i ]. x - s . x ) * ( mmp [ i ]. x - s . x ) + ( mmp [ i ]. y - s . y ) * ( mmp [ i ]. y - s . y ) > r * r ) continue ; //\u8ddd\u79bb\u4e0d\u591f\u5c31\u4e0d\u8d70 vis [ i ] = true ; int kk ; if ( i > n ) kk = s . k + 1 ; else kk = s . k ; //\u6839\u636e\u5f53\u524d\u8282\u70b9\u7684\u7c7b\u578b\u51b3\u5b9a\u662f\u5426\u52a0k\u503c Q . push ( node ( mmp [ i ]. x , mmp [ i ]. y , s . step + 1 , kk )); } } } int main () { cin >> n >> m >> k >> r ; rep ( i , 1 , n + m ) cin >> mmp [ i ]. x >> mmp [ i ]. y ; cout << bfs ( 1 , 2 ); //\u8f93\u5165\u7ed3\u679c return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/","text":"\u8bd5\u9898\u7f16\u53f7\uff1a 201312-5 \u00b6 \u8bd5\u9898\u540d\u79f0\uff1a I\u2019m stuck! \u00b6 \u65f6\u95f4\u9650\u5236\uff1a 1.0s \u00b6 \u5185\u5b58\u9650\u5236\uff1a 256.0MB \u00b6 \u95ee\u9898\u63cf\u8ff0 \u00b6 \u539f\u9898\u94fe\u63a5: http://118.190.20.162/view.page?gpid=T1 \u7ed9\u5b9a\u4e00\u4e2aR\u884cC\u5217\u7684\u5730\u56fe\uff0c\u5730\u56fe\u7684\u6bcf\u4e00\u4e2a\u65b9\u683c\u53ef\u80fd\u662f'#', '+', '-', '|', '.', 'S', 'T'\u4e03\u4e2a\u5b57\u7b26\u4e2d\u7684\u4e00\u4e2a\uff0c\u5206\u522b\u8868\u793a\u5982\u4e0b\u610f\u601d\uff1a '#': \u4efb\u4f55\u65f6\u5019\u73a9\u5bb6\u90fd\u4e0d\u80fd\u79fb\u52a8\u5230\u6b64\u65b9\u683c\uff1b \u3000 '+': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '-': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u5de6\u53f3\u4e24\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '|': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u4e24\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '. ': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ea\u80fd\u5411\u4e0b\u79fb\u52a8\u4e00\u683c\u3002\u5982\u679c\u4e0b\u9762\u76f8\u90bb\u7684\u65b9\u683c\u4e3a'#'\uff0c\u5219\u73a9\u5bb6\u4e0d\u80fd\u518d\u79fb\u52a8\uff1b \u3000 'S': \u73a9\u5bb6\u7684\u521d\u59cb\u4f4d\u7f6e\uff0c\u5730\u56fe\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u521d\u59cb\u4f4d\u7f6e\u3002\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 'T': \u73a9\u5bb6\u7684\u76ee\u6807\u4f4d\u7f6e\uff0c\u5730\u56fe\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u76ee\u6807\u4f4d\u7f6e\u3002\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u53ef\u4ee5\u9009\u62e9\u5b8c\u6210\u4efb\u52a1\uff0c\u4e5f\u53ef\u4ee5\u9009\u62e9\u4e0d\u5b8c\u6210\u4efb\u52a1\u7ee7\u7eed\u79fb\u52a8\u3002\u5982\u679c\u7ee7\u7eed\u79fb\u52a8\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\u3002 \u3000\u3000\u6b64\u5916\uff0c\u73a9\u5bb6\u4e0d\u80fd\u79fb\u52a8\u51fa\u5730\u56fe\u3002 \u8bf7\u627e\u51fa\u6ee1\u8db3\u4e0b\u9762\u4e24\u4e2a\u6027\u8d28\u7684\u65b9\u683c\u4e2a\u6570\uff1a 1. \u73a9\u5bb6\u53ef\u4ee5\u4ece\u521d\u59cb\u4f4d\u7f6e\u79fb\u52a8\u5230\u6b64\u65b9\u683c\uff1b 2. \u73a9\u5bb6\u4e0d\u53ef\u4ee5\u4ece\u6b64\u65b9\u683c\u79fb\u52a8\u5230\u76ee\u6807\u4f4d\u7f6e\u3002 \u8f93\u5165\u683c\u5f0f \u00b6 \u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e24\u4e2a\u6574\u6570R \u548cC\uff0c\u5206\u522b\u8868\u793a\u5730\u56fe\u7684\u884c\u548c\u5217\u6570\u3002(1 \u2264 R, C \u2264 50)\u3002 \u3000\u3000\u63a5\u4e0b\u6765\u7684R\u884c\u6bcf\u884c\u90fd\u5305\u542bC\u4e2a\u5b57\u7b26\u3002\u5b83\u4eec\u8868\u793a\u5730\u56fe\u7684\u683c\u5b50\u3002\u5730\u56fe\u4e0a\u6070\u597d\u6709\u4e00\u4e2a'S'\u548c\u4e00\u4e2a'T'\u3002 \u8f93\u51fa\u683c\u5f0f \u00b6 \u5982\u679c\u73a9\u5bb6\u5728\u521d\u59cb\u4f4d\u7f6e\u5c31\u5df2\u7ecf\u4e0d\u80fd\u5230\u8fbe\u7ec8\u70b9\u4e86\uff0c\u5c31\u8f93\u51fa\u201cI'm stuck!\u201d\uff08\u4e0d\u542b\u53cc\u5f15\u53f7\uff09\u3002\u5426\u5219\u7684\u8bdd\uff0c\u8f93\u51fa\u6ee1\u8db3\u6027\u8d28\u7684\u65b9\u683c\u7684\u4e2a\u6570\u3002 \u6837\u4f8b\u8f93\u5165 \u00b6 5 5 --+-+ ..|#. ..|## S-+-T ####. \u6837\u4f8b\u8f93\u51fa \u00b6 2 \u6837\u4f8b\u8bf4\u660e \u00b6 \u5982\u679c\u628a\u6ee1\u8db3\u6027\u8d28\u7684\u65b9\u683c\u5728\u5730\u56fe\u4e0a\u7528'X'\u6807\u8bb0\u51fa\u6765\u7684\u8bdd\uff0c\u5730\u56fe\u5982\u4e0b\u6240\u793a\uff1a --+-+ ..|#X ..|## S-+-T ####X \u9898\u610f \u00b6 \u6839\u636e\u9898\u610f\u4f7f\u7528BFS\u6a21\u62df\u641c\u7d22\u8fc7\u7a0b\u5373\u53ef\u3002\u6b64\u9898\u7ec6\u8282\u8f83\u591a\uff0c\u503c\u5f97\u6ce8\u610f\u3002 \u601d\u8def \u00b6 \u4eceS\u70b9\u5f00\u59cb\u641c\u7d22\u627e\u5230\u6240\u6709\u80fd\u5230\u8fbe\u7684\u70b9\u3002\u4ece\u6240\u6709\u80fd\u5230\u8fbe\u7684\u70b9\u5f00\u59cb\u518d\u8fdb\u884c\u641c\u7d22\u627e\u5230\u7b54\u6848\u5373\u53ef\u3002 AC\u4ee3\u7801 \u00b6 #pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define rep(z, x, y) for(int z=x;z<=y;++z) #define repd(z, x, y) for(int z=x;z>=y;--z) #define ft first #define sd second #define pb push_back const int maxn = 50 + 5 ; const int mod = 998244353 ; const int inf = 0x3f3f3f3f ; using namespace std ; char mmp [ maxn ][ maxn ]; int n , m ; bool vis [ maxn ][ maxn ], stk ; int walk [ 4 ][ 2 ] = {{ 1 , 0 },{ -1 , 0 },{ 0 , 1 },{ 0 , -1 }}; struct poi { poi ( int _x = 0 , int _y = 0 , char _val = 'a' ) : x ( _x ), y ( _y ), val ( _val ){} int x , y ; char val ; } beg , ed ; bool check ( int dx , int dy ){ if ( dx >= 1 && dx <= n && dy >= 1 && dy <= m && mmp [ dx ][ dy ] != '#' && ! vis [ dx ][ dy ]) return true ; else return false ; } void bfs ( poi beg ){ queue < poi > ss ; ss . push ( beg ); vis [ beg . x ][ beg . y ] = 1 ; while ( ! ss . empty ()){ poi temp = ss . front (); ss . pop (); int dx = 0 , dy = 0 ; if ( temp . val == 'S' || temp . val == '+' || temp . val == 'T' ){ rep ( i , 0 , 3 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '-' ){ rep ( i , 2 , 3 ){ dx = temp . x ; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '.' ){ dx = temp . x + 1 ; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } else if ( temp . val == '|' ){ rep ( i , 0 , 1 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } } } bool bfs2 ( poi p ){ queue < poi > ss ; ss . push ( p ); while ( ! ss . empty ()){ poi temp = ss . front (); ss . pop (); if ( temp . val == 'T' ){ return false ; } int dx = 0 , dy = 0 ; if ( temp . val == 'S' || temp . val == '+' || temp . val == 'T' ){ rep ( i , 0 , 3 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '-' ){ rep ( i , 2 , 3 ){ dx = temp . x ; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '.' ){ dx = temp . x + 1 ; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } else if ( temp . val == '|' ){ rep ( i , 0 , 1 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } } return true ; } int main () { start ; cin >> n >> m ; rep ( i , 1 , n ){ rep ( j , 1 , m ){ cin >> mmp [ i ][ j ]; if ( mmp [ i ][ j ] == 'S' ) beg = poi ( i , j , mmp [ i ][ j ]); else if ( mmp [ i ][ j ] == 'T' ) ed = poi ( i , j , mmp [ i ][ j ]); } } bfs ( beg ); /* rep(i,1,n){ rep(j,1,m){ if(vis[i][j]) cout<<mmp[i][j]<<' '; else cout<<'#'<<' '; } cout<<endl; }*/ if ( ! vis [ ed . x ][ ed . y ]) cout << \"I'm stuck! \\n \" ; else { int cnt = 0 ; queue < poi > t ; rep ( i , 1 , n ) rep ( j , 1 , m ) if ( vis [ i ][ j ]) t . push ( poi ( i , j , mmp [ i ][ j ])); while ( ! t . empty ()){ poi tt = t . front (); t . pop (); memset ( vis , 0 , sizeof vis ); if ( bfs2 ( tt )) cnt ++ ; } cout << cnt << endl ; } return 0 ; }","title":"201312-5"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#201312-5","text":"","title":"\u8bd5\u9898\u7f16\u53f7\uff1a 201312-5"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#im-stuck","text":"","title":"\u8bd5\u9898\u540d\u79f0\uff1a I\u2019m stuck!"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#10s","text":"","title":"\u65f6\u95f4\u9650\u5236\uff1a   1.0s"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#2560mb","text":"","title":"\u5185\u5b58\u9650\u5236\uff1a    256.0MB"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_1","text":"\u539f\u9898\u94fe\u63a5: http://118.190.20.162/view.page?gpid=T1 \u7ed9\u5b9a\u4e00\u4e2aR\u884cC\u5217\u7684\u5730\u56fe\uff0c\u5730\u56fe\u7684\u6bcf\u4e00\u4e2a\u65b9\u683c\u53ef\u80fd\u662f'#', '+', '-', '|', '.', 'S', 'T'\u4e03\u4e2a\u5b57\u7b26\u4e2d\u7684\u4e00\u4e2a\uff0c\u5206\u522b\u8868\u793a\u5982\u4e0b\u610f\u601d\uff1a '#': \u4efb\u4f55\u65f6\u5019\u73a9\u5bb6\u90fd\u4e0d\u80fd\u79fb\u52a8\u5230\u6b64\u65b9\u683c\uff1b \u3000 '+': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '-': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u5de6\u53f3\u4e24\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '|': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u4e24\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 '. ': \u5f53\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ea\u80fd\u5411\u4e0b\u79fb\u52a8\u4e00\u683c\u3002\u5982\u679c\u4e0b\u9762\u76f8\u90bb\u7684\u65b9\u683c\u4e3a'#'\uff0c\u5219\u73a9\u5bb6\u4e0d\u80fd\u518d\u79fb\u52a8\uff1b \u3000 'S': \u73a9\u5bb6\u7684\u521d\u59cb\u4f4d\u7f6e\uff0c\u5730\u56fe\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u521d\u59cb\u4f4d\u7f6e\u3002\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\uff1b \u3000 'T': \u73a9\u5bb6\u7684\u76ee\u6807\u4f4d\u7f6e\uff0c\u5730\u56fe\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u76ee\u6807\u4f4d\u7f6e\u3002\u73a9\u5bb6\u5230\u8fbe\u8fd9\u4e00\u65b9\u683c\u540e\uff0c\u53ef\u4ee5\u9009\u62e9\u5b8c\u6210\u4efb\u52a1\uff0c\u4e5f\u53ef\u4ee5\u9009\u62e9\u4e0d\u5b8c\u6210\u4efb\u52a1\u7ee7\u7eed\u79fb\u52a8\u3002\u5982\u679c\u7ee7\u7eed\u79fb\u52a8\u4e0b\u4e00\u6b65\u53ef\u4ee5\u5411\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u76f8\u90bb\u7684\u4efb\u610f\u4e00\u4e2a\u975e'#'\u65b9\u683c\u79fb\u52a8\u4e00\u683c\u3002 \u3000\u3000\u6b64\u5916\uff0c\u73a9\u5bb6\u4e0d\u80fd\u79fb\u52a8\u51fa\u5730\u56fe\u3002 \u8bf7\u627e\u51fa\u6ee1\u8db3\u4e0b\u9762\u4e24\u4e2a\u6027\u8d28\u7684\u65b9\u683c\u4e2a\u6570\uff1a 1. \u73a9\u5bb6\u53ef\u4ee5\u4ece\u521d\u59cb\u4f4d\u7f6e\u79fb\u52a8\u5230\u6b64\u65b9\u683c\uff1b 2. \u73a9\u5bb6\u4e0d\u53ef\u4ee5\u4ece\u6b64\u65b9\u683c\u79fb\u52a8\u5230\u76ee\u6807\u4f4d\u7f6e\u3002","title":"\u95ee\u9898\u63cf\u8ff0"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_2","text":"\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u5305\u62ec\u4e24\u4e2a\u6574\u6570R \u548cC\uff0c\u5206\u522b\u8868\u793a\u5730\u56fe\u7684\u884c\u548c\u5217\u6570\u3002(1 \u2264 R, C \u2264 50)\u3002 \u3000\u3000\u63a5\u4e0b\u6765\u7684R\u884c\u6bcf\u884c\u90fd\u5305\u542bC\u4e2a\u5b57\u7b26\u3002\u5b83\u4eec\u8868\u793a\u5730\u56fe\u7684\u683c\u5b50\u3002\u5730\u56fe\u4e0a\u6070\u597d\u6709\u4e00\u4e2a'S'\u548c\u4e00\u4e2a'T'\u3002","title":"\u8f93\u5165\u683c\u5f0f"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_3","text":"\u5982\u679c\u73a9\u5bb6\u5728\u521d\u59cb\u4f4d\u7f6e\u5c31\u5df2\u7ecf\u4e0d\u80fd\u5230\u8fbe\u7ec8\u70b9\u4e86\uff0c\u5c31\u8f93\u51fa\u201cI'm stuck!\u201d\uff08\u4e0d\u542b\u53cc\u5f15\u53f7\uff09\u3002\u5426\u5219\u7684\u8bdd\uff0c\u8f93\u51fa\u6ee1\u8db3\u6027\u8d28\u7684\u65b9\u683c\u7684\u4e2a\u6570\u3002","title":"\u8f93\u51fa\u683c\u5f0f"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_4","text":"5 5 --+-+ ..|#. ..|## S-+-T ####.","title":"\u6837\u4f8b\u8f93\u5165"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_5","text":"2","title":"\u6837\u4f8b\u8f93\u51fa"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_6","text":"\u5982\u679c\u628a\u6ee1\u8db3\u6027\u8d28\u7684\u65b9\u683c\u5728\u5730\u56fe\u4e0a\u7528'X'\u6807\u8bb0\u51fa\u6765\u7684\u8bdd\uff0c\u5730\u56fe\u5982\u4e0b\u6240\u793a\uff1a --+-+ ..|#X ..|## S-+-T ####X","title":"\u6837\u4f8b\u8bf4\u660e"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_7","text":"\u6839\u636e\u9898\u610f\u4f7f\u7528BFS\u6a21\u62df\u641c\u7d22\u8fc7\u7a0b\u5373\u53ef\u3002\u6b64\u9898\u7ec6\u8282\u8f83\u591a\uff0c\u503c\u5f97\u6ce8\u610f\u3002","title":"\u9898\u610f"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#_8","text":"\u4eceS\u70b9\u5f00\u59cb\u641c\u7d22\u627e\u5230\u6240\u6709\u80fd\u5230\u8fbe\u7684\u70b9\u3002\u4ece\u6240\u6709\u80fd\u5230\u8fbe\u7684\u70b9\u5f00\u59cb\u518d\u8fdb\u884c\u641c\u7d22\u627e\u5230\u7b54\u6848\u5373\u53ef\u3002","title":"\u601d\u8def"},{"location":"mm/%E8%AF%95%E9%A2%98%E7%BC%96%E5%8F%B7%EF%BC%9A201312-5/#ac","text":"#pragma GCC optimize(3, \"Ofast\", \"inline\") #include <bits/stdc++.h> #define start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define rep(z, x, y) for(int z=x;z<=y;++z) #define repd(z, x, y) for(int z=x;z>=y;--z) #define ft first #define sd second #define pb push_back const int maxn = 50 + 5 ; const int mod = 998244353 ; const int inf = 0x3f3f3f3f ; using namespace std ; char mmp [ maxn ][ maxn ]; int n , m ; bool vis [ maxn ][ maxn ], stk ; int walk [ 4 ][ 2 ] = {{ 1 , 0 },{ -1 , 0 },{ 0 , 1 },{ 0 , -1 }}; struct poi { poi ( int _x = 0 , int _y = 0 , char _val = 'a' ) : x ( _x ), y ( _y ), val ( _val ){} int x , y ; char val ; } beg , ed ; bool check ( int dx , int dy ){ if ( dx >= 1 && dx <= n && dy >= 1 && dy <= m && mmp [ dx ][ dy ] != '#' && ! vis [ dx ][ dy ]) return true ; else return false ; } void bfs ( poi beg ){ queue < poi > ss ; ss . push ( beg ); vis [ beg . x ][ beg . y ] = 1 ; while ( ! ss . empty ()){ poi temp = ss . front (); ss . pop (); int dx = 0 , dy = 0 ; if ( temp . val == 'S' || temp . val == '+' || temp . val == 'T' ){ rep ( i , 0 , 3 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '-' ){ rep ( i , 2 , 3 ){ dx = temp . x ; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '.' ){ dx = temp . x + 1 ; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } else if ( temp . val == '|' ){ rep ( i , 0 , 1 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } } } bool bfs2 ( poi p ){ queue < poi > ss ; ss . push ( p ); while ( ! ss . empty ()){ poi temp = ss . front (); ss . pop (); if ( temp . val == 'T' ){ return false ; } int dx = 0 , dy = 0 ; if ( temp . val == 'S' || temp . val == '+' || temp . val == 'T' ){ rep ( i , 0 , 3 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '-' ){ rep ( i , 2 , 3 ){ dx = temp . x ; dy = temp . y + walk [ i ][ 1 ]; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } else if ( temp . val == '.' ){ dx = temp . x + 1 ; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } else if ( temp . val == '|' ){ rep ( i , 0 , 1 ){ dx = temp . x + walk [ i ][ 0 ]; dy = temp . y ; if ( check ( dx , dy )){ vis [ dx ][ dy ] = 1 ; ss . push ( poi ( dx , dy , mmp [ dx ][ dy ])); } } } } return true ; } int main () { start ; cin >> n >> m ; rep ( i , 1 , n ){ rep ( j , 1 , m ){ cin >> mmp [ i ][ j ]; if ( mmp [ i ][ j ] == 'S' ) beg = poi ( i , j , mmp [ i ][ j ]); else if ( mmp [ i ][ j ] == 'T' ) ed = poi ( i , j , mmp [ i ][ j ]); } } bfs ( beg ); /* rep(i,1,n){ rep(j,1,m){ if(vis[i][j]) cout<<mmp[i][j]<<' '; else cout<<'#'<<' '; } cout<<endl; }*/ if ( ! vis [ ed . x ][ ed . y ]) cout << \"I'm stuck! \\n \" ; else { int cnt = 0 ; queue < poi > t ; rep ( i , 1 , n ) rep ( j , 1 , m ) if ( vis [ i ][ j ]) t . push ( poi ( i , j , mmp [ i ][ j ])); while ( ! t . empty ()){ poi tt = t . front (); t . pop (); memset ( vis , 0 , sizeof vis ); if ( bfs2 ( tt )) cnt ++ ; } cout << cnt << endl ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"vj/t1/","text":"","title":"Data structure"},{"location":"vj/kb/t1/FZU%202150%20Fire%20Game/","text":"","title":"FZU 2150 Fire Game"},{"location":"vj/kb/t1/HDU%201241%20Oil%20Deposits/","text":"","title":"HDU 1241 Oil Deposits"},{"location":"vj/kb/t1/HDU%201495%20%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/","text":"","title":"HDU 1495 \u975e\u5e38\u53ef\u4e50"},{"location":"vj/kb/t1/HDU%202612%20Find%20a%20way/","text":"","title":"HDU 2612 Find a way"},{"location":"vj/kb/t1/POJ%201321%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/","text":"POJ - 1321 \u68cb\u76d8\u95ee\u9898 \u00b6 #include <iostream> #include <cstring> using namespace std ; #define maxn 9 int mmp [ maxn ][ maxn ]; bool checky [ maxn ]; long long n , k , ans ; void dfs ( long long x , long long num ){ if ( num == k ){ //cout<<x<<endl; ans ++ ; return ; } for ( long long i = x + 1 ; i <= n ; i ++ ){ for ( long long j = 1 ; j <= n ; j ++ ){ if ( mmp [ i ][ j ] &&! checky [ j ]){ checky [ j ] = true ; dfs ( i , num + 1 ); checky [ j ] = false ; } } } } int main (){ char get ; while ( cin >> n >> k ){ if ( n == -1 && k == -1 ){ break ; } ans = 0 ; memset ( mmp , 0 , sizeof ( mmp )); memset ( checky , 0 , sizeof ( checky )); for ( long long i = 1 ; i <= n ; i ++ ){ for ( long long j = 1 ; j <= n ; j ++ ){ cin >> get ; if ( get == '#' ) mmp [ i ][ j ] = 1 ; } } dfs ( 0 , 0 ); cout << ans << endl ; } return 0 ; }","title":"POJ 1321 \u68cb\u76d8\u95ee\u9898"},{"location":"vj/kb/t1/POJ%201321%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/#poj-1321","text":"#include <iostream> #include <cstring> using namespace std ; #define maxn 9 int mmp [ maxn ][ maxn ]; bool checky [ maxn ]; long long n , k , ans ; void dfs ( long long x , long long num ){ if ( num == k ){ //cout<<x<<endl; ans ++ ; return ; } for ( long long i = x + 1 ; i <= n ; i ++ ){ for ( long long j = 1 ; j <= n ; j ++ ){ if ( mmp [ i ][ j ] &&! checky [ j ]){ checky [ j ] = true ; dfs ( i , num + 1 ); checky [ j ] = false ; } } } } int main (){ char get ; while ( cin >> n >> k ){ if ( n == -1 && k == -1 ){ break ; } ans = 0 ; memset ( mmp , 0 , sizeof ( mmp )); memset ( checky , 0 , sizeof ( checky )); for ( long long i = 1 ; i <= n ; i ++ ){ for ( long long j = 1 ; j <= n ; j ++ ){ cin >> get ; if ( get == '#' ) mmp [ i ][ j ] = 1 ; } } dfs ( 0 , 0 ); cout << ans << endl ; } return 0 ; }","title":"POJ - 1321 \u68cb\u76d8\u95ee\u9898"},{"location":"vj/kb/t1/POJ%201426%20Find%20The%20Multiple/","text":"","title":"POJ 1426 Find The Multiple"},{"location":"vj/kb/t1/POJ%202251%20Dungeon%20Master/","text":"","title":"POJ 2251 Dungeon Master"},{"location":"vj/kb/t1/POJ%203087%20Shuffle%27m%20Up/","text":"","title":"POJ 3087 Shuffle'm Up"},{"location":"vj/kb/t1/POJ%203126%20Prime%20Path/","text":"","title":"POJ 3126 Prime Path"},{"location":"vj/kb/t1/POJ%203278%20Catch%20That%20Cow/","text":"","title":"POJ 3278 Catch That Cow"},{"location":"vj/kb/t1/POJ%203279%20Fliptile/","text":"","title":"POJ 3279 Fliptile"},{"location":"vj/kb/t1/POJ%203414%20Pots/","text":"","title":"POJ 3414 Pots"},{"location":"vj/kb/t1/POJ%203984%20%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","text":"","title":"POJ 3984 \u8ff7\u5bab\u95ee\u9898"},{"location":"vj/kb/t1/UVA%2011624%20Fire%21/","text":"","title":"UVA 11624 Fire!"}]}